console.log('ğŸ¯ ToneBridge audio-analysis.js loaded');
/**
 * ToneBridge Audio Analysis Frontend
 * Real-time pitch tracking and overlay visualization
 */

// Use API_BASE from window if available, otherwise default to current origin
const API_BASE = window.API_BASE || "";

// DOM Elements - Initialize after DOM is ready
let $wav, $tg, $btnAnalyze, $btnMic, $btnReset, $btnClearChart, $status, $btnPlayRef, $btnPlayRec, $savedFiles, $btnSaveReference, $semitoneMin, $semitoneMax, $btnUpdateRange;
let $btnPitchTest, $btnStopPitchTest, $pitchTestStatus, $freqRangeDisplay, $btnClearRange, $btnDeleteSaved, $btnReplayPractice;

function initializeElements() {
    $wav = document.getElementById('wav');
    $tg = document.getElementById('tg');
    $btnAnalyze = document.getElementById('btnAnalyze');
    $btnMic = document.getElementById('btnUnifiedRecord'); // ğŸ¯ ì‹¤ì œ í…œí”Œë¦¿ì˜ í†µí•© ë…¹ìŒ ë²„íŠ¼ ì‚¬ìš©
    $btnReset = document.getElementById('btnReset');
    $btnClearChart = document.getElementById('btnClearChart');
    $status = document.getElementById('status');
    $btnPlayRef = document.getElementById('btnPlayRef');
    $btnPlayRec = document.getElementById('btnPlayRec');
    $savedFiles = document.getElementById('savedFiles');
    $btnSaveReference = document.getElementById('btnSaveReference');
    $semitoneMin = document.getElementById('semitoneMin');
    $semitoneMax = document.getElementById('semitoneMax');
    $btnUpdateRange = document.getElementById('btnUpdateRange');
    $btnPitchTest = document.getElementById('btnPitchTest');
    $btnStopPitchTest = document.getElementById('btnStopPitchTest');
    $pitchTestStatus = document.getElementById('pitchTestStatus');
    $freqRangeDisplay = document.getElementById('freqRangeDisplay');
    $btnClearRange = document.getElementById('btnClearRange');
    $btnDeleteSaved = document.getElementById('btnDeleteSaved');
    $btnReplayPractice = document.getElementById('btnReplayPractice');
    $btnTwoPointPractice = document.getElementById('btnTwoPointPractice');
    
    console.log('DOM elements found:', {
        wav: !!$wav,
        tg: !!$tg,
        btnAnalyze: !!$btnAnalyze,
        btnMic: !!$btnMic, // ì´ì œ btnUnifiedRecordë¥¼ ê°€ë¦¬í‚´
        btnReset: !!$btnReset,
        btnClearChart: !!$btnClearChart,
        status: !!$status,
        btnPlayRef: !!$btnPlayRef,
        btnPlayRec: !!$btnPlayRec,
        savedFiles: !!$savedFiles,
        btnSaveReference: !!$btnSaveReference,
        semitoneMin: !!$semitoneMin,
        semitoneMax: !!$semitoneMax,
        btnUpdateRange: !!$btnUpdateRange,
        btnPitchTest: !!$btnPitchTest,
        btnStopPitchTest: !!$btnStopPitchTest,
        pitchTestStatus: !!$pitchTestStatus,
        freqRangeDisplay: !!$freqRangeDisplay,
        btnClearRange: !!$btnClearRange,
        btnDeleteSaved: !!$btnDeleteSaved,
        btnReplayPractice: !!$btnReplayPractice
    });
    
    if (!$wav) console.error('WAV input not found');
    if (!$tg) console.error('TextGrid input not found'); 
    if (!$btnAnalyze) console.error('Analyze button not found');
    
    // ğŸ¯ Pitch Test ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì •
    setupPitchTestHandlers();
    
    // ğŸ¯ ë²”ìœ„ í•´ì œ ë²„íŠ¼ í•¸ë“¤ëŸ¬
    if ($btnClearRange) {
        $btnClearRange.onclick = () => {
            clearPitchRange();
            pitchRange = null;
            targetPitch = null;
            updatePitchTestButtons();
            
            if ($pitchTestStatus) {
                $pitchTestStatus.textContent = "ì°¨íŠ¸ë¥¼ í´ë¦­í•˜ê³  ë“œë˜ê·¸í•´ì„œ ì—°ìŠµ ë²”ìœ„ë¥¼ ì„¤ì •í•˜ê±°ë‚˜ í•œ ì ì„ í´ë¦­í•´ì„œ ëª©í‘œ ìŒë†’ì´ë¥¼ ì„¤ì •í•˜ì„¸ìš”";
                $pitchTestStatus.className = "text-center text-danger small fw-bold";
            }
            
            console.log("ğŸ¯ ìŒë†’ì´ ë²”ìœ„ ë° ëª©í‘œ í•´ì œë¨");
        };
    }
    
    // ğŸ¯ ì´ˆê¸° Hz ë²”ìœ„ í‘œì‹œ
    updateFrequencyRangeDisplay(-6, 12);
}

// Analysis State
let refCurve = [];
let refSyll = [];
let refStats = {meanF0: 0, maxF0: 0, duration: 0};
let liveStats = {meanF0: 0, maxF0: 0};
let spectrogramData = [];
let liveBuffer = [];
let started = false;
let refMedian = 200; // Reference median for semitone calculation

// Audio Processing Configuration - optimized for pitch tracking
const cfg = {
    sampleRate: 16000,
    frameMs: 32,   // Longer frame for better low pitch detection
    hopMs: 8       // Smaller hop for smoother tracking
};

let audioCtx, micNode, procNode;
let tLive = 0;
let sylCuts = [];

// Audio playback variables
let refAudioBlob = null;
let recordedAudioBlob = null;
let selectedGender = null;
let detectedReferenceGender = null;
let learningMethod = null;
let learnerGender = null;
let progressStep = 0;
let currentlyPlaying = null;
let mediaRecorder = null;

// Pitch Test variables
let pitchTestActive = false;
let targetPitch = null; // Target semitone value
let pitchTestBuffer = [];
let chartFrozen = false; // ğŸ¯ ì°¨íŠ¸ ê³ ì • ìƒíƒœ (ìŒë†’ì´ í…ŒìŠ¤íŠ¸ ì¤‘)
let originalScales = null; // ğŸ¯ ìŒë†’ì´ í…ŒìŠ¤íŠ¸ ì‹œì‘ ì „ ì›ë³¸ ì°¨íŠ¸ ìŠ¤ì¼€ì¼
let pitchTestLine = null; // Chart reference line
let pitchTestStream = null;
let pitchTestAudioCtx = null;
let pitchTestProcNode = null;
let recordedChunks = [];

// Range selection variables
let isSelecting = false;
let rangeStart = null;
let rangeEnd = null;
let currentLiveHz = 0; // ì‹¤ì‹œê°„ Hz ê°’
let pitchRange = null; // {min, max} ë²”ìœ„ ì €ì¥

// EdTech Learning Progress Variables
let learningProgress = 0;
let pronunciationScore = 0;
let startTime = 0; // ğŸ¯ ì˜¤ë””ì˜¤ ì‹œì‘ ì‹œê°„
let totalSteps = 4; // íŒŒì¼ì¤€ë¹„, ë¶„ì„, ì—°ìŠµ, ê²°ê³¼í™•ì¸

// Update EdTech Progress Elements
function updateLearningProgress(step, score = null) {
    learningProgress = Math.min(step / totalSteps * 100, 100);
    const progressBar = document.getElementById('progressBar');
    const scoreElement = document.getElementById('pronunciationScore');
    
    if (progressBar) {
        progressBar.style.width = `${learningProgress}%`;
        progressBar.setAttribute('aria-valuenow', learningProgress);
    }
    
    if (score !== null) {
        pronunciationScore = score;
        if (scoreElement) {
            scoreElement.textContent = `${score}ì `;
            scoreElement.className = `h5 ${score >= 80 ? 'text-success' : score >= 60 ? 'text-warning' : 'text-danger'}`;
        }
    }
}

// Calculate pronunciation similarity score
function calculatePronunciationScore() {
    if (refCurve.length === 0 || liveBuffer.length === 0) return 0;
    
    let similarity = 0;
    let count = 0;
    
    // Compare pitch patterns
    const minLength = Math.min(refCurve.length, liveBuffer.length);
    for (let i = 0; i < minLength; i += 10) { // Sample every 10th point for efficiency
        if (refCurve[i] && liveBuffer[i] && refCurve[i].f0 > 0 && liveBuffer[i].f0 > 0) {
            const refPitch = refCurve[i].f0;
            const livePitch = liveBuffer[i].f0;
            const diff = Math.abs(refPitch - livePitch) / refPitch;
            similarity += Math.max(0, 1 - diff);
            count++;
        }
    }
    
    return count > 0 ? Math.round((similarity / count) * 100) : 0;
}

// Update button states
function updateButtons() {
    const hasWav = $wav && $wav.files && $wav.files.length > 0;
    const hasTextGrid = $tg && $tg.files && $tg.files.length > 0;
    const hasRefData = refCurve.length > 0 && refSyll.length > 0;
    const hasRecording = recordedAudioBlob !== null;
    const canSave = hasWav && hasTextGrid;
    
    console.log('Updating buttons:', {
        hasWav,
        hasTextGrid,
        hasRefData,
        hasRecording,
        wavFiles: $wav ? $wav.files.length : 0,
        tgFiles: $tg ? $tg.files.length : 0
    });
    
    if ($btnAnalyze) {
        // ğŸ¯ í•™ìŠµ ë°©ë²•ë³„ ìš°ì„  ì¡°ê±´ í™•ì¸
        if (learningMethod === 'sentence') {
            // ë¬¸ì¥ì–µì–‘ì—°ìŠµ: ë¶„ì„ ë²„íŠ¼ í™œì„±í™”
            $btnAnalyze.disabled = !(hasWav && hasTextGrid);
        } else if (learningMethod === 'pitch') {
            // ìŒë†’ì´ í•™ìŠµ: ë¶„ì„ ë²„íŠ¼ ë¹„í™œì„±í™”
            $btnAnalyze.disabled = true;
        } else {
            // ë¯¸ì„ íƒ: WAV + TextGrid íŒŒì¼ì´ ìˆìœ¼ë©´ í™œì„±í™”
            $btnAnalyze.disabled = !(hasWav && hasTextGrid);
        }
        console.log('Analyze button disabled:', $btnAnalyze.disabled, '(í•™ìŠµë°©ë²•:', learningMethod + ')');
    }
    
    if ($btnMic) {
        // ğŸ¯ í•™ìŠµ ë°©ë²•ë³„ ìš°ì„  ì¡°ê±´ í™•ì¸
        if (learningMethod === 'pitch') {
            // ìŒë†’ì´ í•™ìŠµ: ë…¹ìŒ ë²„íŠ¼ í™œì„±í™”
            $btnMic.disabled = false;
        } else if (learningMethod === 'sentence') {
            // ë¬¸ì¥ì–µì–‘ì—°ìŠµ: í•­ìƒ í™œì„±í™” (ê°„ë‹¨í•˜ê²Œ)
            $btnMic.disabled = false;
        } else {
            // ë¯¸ì„ íƒ: ë¶„ì„ ë²„íŠ¼ë§Œ í™œì„±í™”
            $btnMic.disabled = !(hasWav && hasTextGrid); // íŒŒì¼ ìˆìœ¼ë©´ í™œì„±í™”
        }
        console.log('Record button disabled:', $btnMic.disabled, '(í•™ìŠµë°©ë²•:', learningMethod + ')');
    }
    
    if ($btnPlayRef) {
        $btnPlayRef.disabled = !hasWav;
    }
    
    if ($btnPlayRec) {
        $btnPlayRec.disabled = !hasRecording;
    }
    
    if ($btnSaveReference) {
        $btnSaveReference.disabled = !canSave;
    }
    
    // ğŸ¯ í”¼ì¹˜ í…ŒìŠ¤íŠ¸ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    updatePitchTestButtons();
    
    // Update EdTech status message with learning context
    if ($status) {
        if (!hasWav && !hasTextGrid) {
            $status.textContent = "ğŸ“± íœ´ëŒ€í°ì„ ê°€ë¡œë³´ê¸°ë¡œ í•˜ì‹œë©´ ê·¸ë˜í”„ë¥¼ í•œëˆˆì— ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
            updateLearningProgress(0);
        } else if (!hasWav) {
            $status.textContent = "ğŸµ í‘œì¤€ ì–µì–‘ WAV íŒŒì¼ì„ ì„ íƒí•´ ì£¼ì„¸ìš”.";
            updateLearningProgress(0.5);
        } else if (!hasTextGrid) {
            $status.textContent = "ğŸ“ ìŒì ˆ êµ¬ë¶„ TextGrid íŒŒì¼ì„ ì„ íƒí•´ ì£¼ì„¸ìš”.";
            updateLearningProgress(0.5);
        } else if (!hasRefData) {
            $status.textContent = "âœ… í•™ìŠµ ìë£Œ ì¤€ë¹„ ì™„ë£Œ! ì´ì œ 'ëª¨ë¸ ìŒì„± ë¶„ì„' ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ í‘œì¤€ ì–µì–‘ íŒ¨í„´ì„ ë¶„ì„í•˜ì„¸ìš”.";
            updateLearningProgress(1);
        } else if (!started) {
            $status.textContent = "ğŸ¯ ë¶„ì„ ì™„ë£Œ! 'ì–µì–‘ ì—°ìŠµ ì‹œì‘' ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì‹¤ì œ ì–µì–‘ ì—°ìŠµì„ ì‹œì‘í•˜ì„¸ìš”.";
            updateLearningProgress(2);
        } else {
            $status.textContent = "ğŸ¤ ì–µì–‘ ì—°ìŠµ ì¤‘... í‘œì¤€ ì–µì–‘ê³¼ ë¹„êµí•˜ë©° ì—°ìŠµí•´ë³´ì„¸ìš”!";
            updateLearningProgress(3);
        }
    }
}

// Initialize all event handlers after DOM is ready
function setupEventHandlers() {
    // File upload handlers
    if ($wav) {
        $wav.addEventListener('change', function(e) {
            console.log('WAV file changed:', e.target.files);
            updateButtons();
            if (e.target.files.length > 0) {
                updateLearningProgress(0.5);
            }
        });
    } else {
        console.error('Cannot add WAV listener - element not found');
    }
    
    if ($tg) {
        $tg.addEventListener('change', function(e) {
            console.log('TextGrid file changed:', e.target.files);
            updateButtons();
            if (e.target.files.length > 0) {
                updateLearningProgress(1);
            }
        });
    } else {
        console.error('Cannot add TextGrid listener - element not found');
    }

    // Button click handlers
    if ($btnAnalyze) {
        $btnAnalyze.onclick = function() {
            const analyzeAsync = async () => {
                try {
                    console.log("ğŸš€ ë¶„ì„ ì‹œì‘ - ì•ˆì „í•œ ì˜¤ë¥˜ ì²˜ë¦¬ ì ìš©");
                    // ğŸ§¹ ë¶„ì„ ì‹œì‘ ì „ ì™„ì „í•œ ë°ì´í„° ì´ˆê¸°í™”
                    console.log("ğŸ§¹ ìƒˆë¡œìš´ ë¶„ì„ ì‹œì‘ - ì´ì „ ë°ì´í„° ì™„ì „ ì´ˆê¸°í™”");
                
                // ì°¨íŠ¸ ë°ì´í„° ì´ˆê¸°í™”
                if (chart) {
                    chart.data.datasets[0].data = [];  // Reference data
                    chart.data.datasets[1].data = [];  // Live data  
                    chart.data.datasets[2].data = [];  // Intensity data
                    if (chart.data.datasets[3]) chart.data.datasets[3].data = [];
                    if (chart.data.datasets[4]) chart.data.datasets[4].data = [];
                }
                
                // ë¶„ì„ ë°ì´í„° ì´ˆê¸°í™”
                refCurve = [];
                refSyll = [];
                refStats = {meanF0: 0, maxF0: 0, duration: 0};
                
                // ìŒì ˆ í‘œì‹œ ì™„ì „ ì œê±° 
                if (chart && chart.options.plugins && chart.options.plugins.annotation) {
                    chart.options.plugins.annotation.annotations = {};
                    chart.update('none');
                    console.log("ğŸ§¹ ìŒì ˆ í‘œì‹œ ì´ˆê¸°í™” ì™„ë£Œ");
                }
                
                // íŒŒì¼ ê²€ì¦
                if (!$wav.files[0] || !$tg.files[0]) {
                    throw new Error("WAV íŒŒì¼ê³¼ TextGrid íŒŒì¼ì„ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”.");
                }
                
                console.log("ğŸ“ íŒŒì¼ í™•ì¸:", {
                    wav: $wav.files[0].name,
                    textgrid: $tg.files[0].name
                });
                
                const fd = new FormData();
                fd.append("wav", $wav.files[0]);
                fd.append("textgrid", $tg.files[0]);
            
            // Add sentence text if provided
            const sentenceText = document.getElementById('sentence-text');
            if (sentenceText && sentenceText.value.trim()) {
                fd.append("sentence", sentenceText.value.trim());
            }
            
                $status.textContent = "ğŸ”„ ì°¸ì¡° ë°ì´í„° ë¶„ì„ ì¤‘...";
                $btnAnalyze.disabled = true;
                
                console.log("ğŸ“¡ ì„œë²„ë¡œ ë¶„ì„ ìš”ì²­ ì „ì†¡...");
                
                const resp = await fetch(`${API_BASE}/analyze_ref?t=${Date.now()}&_=${Math.random()}`, {
                    method: "POST",
                    body: fd,
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache'
                    }
                });
                
                console.log("ğŸ“¡ ì„œë²„ ì‘ë‹µ ìƒíƒœ:", resp.status, resp.statusText);
                
                if (!resp.ok) {
                    const errorText = await resp.text();
                    console.error('ğŸš¨ ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜:', errorText);
                    throw new Error(`ì„œë²„ ì˜¤ë¥˜ (${resp.status}): ${errorText}`);
                }
                
                const js = await resp.json();
                console.log("ğŸ“„ ì„œë²„ ì‘ë‹µ ë°ì´í„°:", js);
                console.log("ğŸ¯ ì‘ë‹µ êµ¬ì¡° í™•ì¸:", {
                    curve: js.curve ? js.curve.length : 'undefined',
                    syllables: js.syllables ? js.syllables.length : 'undefined', 
                    syllable_analysis: js.syllable_analysis ? js.syllable_analysis.length : 'undefined',
                    stats: js.stats ? 'exists' : 'undefined'
                });
                
                // Process reference data
                refCurve = js.curve.map(p => ({
                    t: p.t,
                    f0: p.f0,
                    semitone: p.semitone || 0,  // Include semitone for charting
                    int: normInt(p.dB)
                }));
                
                // ğŸ¯ ìŠ¤í™íŠ¸ë¡œê·¸ë¨ ë°°ê²½ ì²˜ë¦¬ (ì‚¬ìš©ì ìš”ì²­)
                spectrogramData = js.spectrogram || [];
                console.log("ğŸ¯ ì‘ë‹µ ë°ì´í„° í™•ì¸:", {
                    curve_length: js.curve ? js.curve.length : 0,
                    curve_data: js.curve,
                    spectrogram_exists: !!js.spectrogram,
                    spectrogram_length: spectrogramData.length
                });
                
                if (spectrogramData.length > 0) {
                    console.log(`ğŸ¯ ìŠ¤í™íŠ¸ë¡œê·¸ë¨ ë°ì´í„° ìˆ˜ì‹ : ${spectrogramData.length}ê°œ ì‹œì `);
                    // ìŠ¤í™íŠ¸ë¡œê·¸ë¨ í”ŒëŸ¬ê·¸ì¸ ì¦‰ì‹œ ë“±ë¡
                    Chart.register({
                        id: 'spectrogramBackground',
                        beforeDraw: function(chartInstance, args, options) {
                            renderSpectrogramOnCanvas(chartInstance, spectrogramData);
                        }
                    });
                } else {
                    console.log("ğŸ¯ ìŠ¤í™íŠ¸ë¡œê·¸ë¨ ë°ì´í„° ì—†ìŒ");
                }
                
                refSyll = js.syllables;
                refStats = js.stats;
                refMedian = js.stats.sentence_median || 200; // Set reference median for semitone calculation
                console.log("ğŸ¯ Reference median set to:", refMedian);
                
                // ğŸ¯ ì„±ë³„ ê°ì§€ ë° ìë™ ì •ê·œí™” ì ìš©
                detectedReferenceGender = js.stats.detected_gender || (refMedian > 175 ? 'female' : 'male');
                
                // í•™ìŠµì ì„±ë³„ì´ ì´ë¯¸ ì„ íƒëœ ê²½ìš° ìë™ ì •ê·œí™” ì ìš©
                if (learnerGender && learnerGender !== detectedReferenceGender) {
                    console.log(`ğŸ¯ ìë™ ì„±ë³„ ì •ê·œí™”: ${detectedReferenceGender} â†’ ${learnerGender}`);
                    analyzeReferenceWithGender(learnerGender);
                    return;
                }
                
                // Calculate optimal range based on semitone data
                const semitoneValues = refCurve.map(p => p.semitone);
                const optimalRange = calculateOptimalRange(semitoneValues);
                console.log("ğŸ¯ Suggested range:", optimalRange);
                
                // Update chart range
                updateChartRange(optimalRange.min, optimalRange.max);
                
                // ğŸ¯ğŸ¯ğŸ¯ CRITICAL: Update Chart.js with reference data  
                console.log("ğŸ¯ refCurve í™•ì¸:", refCurve ? refCurve.length : "undefined", "points");
                console.log("ğŸ¯ chart ê°ì²´ í™•ì¸:", typeof chart, chart ? "exists" : "undefined");
                
                if (refCurve && refCurve.length > 0) {
                    console.log("ğŸ¯ Updating chart with reference data:", refCurve.length, "points");
                    console.log("ğŸ¯ Sample refCurve data:", refCurve.slice(0, 3));
                    
                    // Update chart data - ì˜¬ë°”ë¥¸ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
                    const chartData = refCurve.map(p => ({x: p.t, y: p.semitone || 0}));
                    chart.data.datasets[0].data = chartData;
                    console.log("ğŸ¯ Chart data updated:", chart.data.datasets[0].data.length, "points");
                    console.log("ğŸ¯ Sample chart data:", chartData.slice(0, 3));
                } else {
                    console.error("ğŸ¯ refCurve is empty or undefined:", refCurve);
                }
                
                // Add syllable annotations
                try {
                    console.log("ğŸ¯ Adding syllable annotations:", refSyll.length, "syllables");
                    addSyllableAnnotations(refSyll);
                    console.log("ğŸ¯ Syllable annotations added successfully!");
                } catch (annotError) {
                    console.error("ğŸ¯ Annotation error:", annotError);
                }
                
                // Force chart update
                try {
                    chart.update();
                    console.log("ğŸ¯ Chart updated successfully!");
                } catch (updateError) {
                    console.error("ğŸ¯ Chart update error:", updateError);
                }
                
                // ğŸ¯ ë…¹ìŒ ê°€ì´ë“œ ì—…ë°ì´íŠ¸
                const guideElement = document.getElementById('guide-text');
                const recordingGuide = document.getElementById('recording-guide');
                if (guideElement && refSyll && refSyll.length > 0) {
                    const syllableText = refSyll.map(s => s.label).join('');
                    guideElement.textContent = syllableText;
                    recordingGuide.style.display = 'block';
                }
                
                // Update syllable analysis table
                if (js.syllable_analysis) {
                    updateSyllableAnalysisTable(js.syllable_analysis);
                }
                
                $status.textContent = `ğŸ¯ í‘œì¤€ ìŒì„± ë¶„ì„ ì™„ë£Œ! ê¸¸ì´: ${refStats.duration.toFixed(2)}ì´ˆ, ìŒì ˆ: ${refSyll.length}ê°œ`;
                
                // Update learning progress - analysis completed
                updateLearningProgress(2);
                
                // Save session data
                await saveSessionData({
                    type: 'reference_analysis',
                    stats: refStats,
                    syllable_count: refSyll.length,
                    timestamp: new Date().toISOString()
                });
                
                updateButtons();
                
            } catch (error) {
                console.error('ğŸš¨ Analysis error:', error);
                console.error('ğŸš¨ Error details:', error.stack);
                $status.textContent = "âŒ ë¶„ì„ ì‹¤íŒ¨: " + (error.message || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜");
                
                // ì˜¤ë¥˜ ìƒì„¸ ì •ë³´ ì¶”ê°€ ë¡œê·¸
                try {
                    if (error.response) {
                        console.error('ğŸš¨ Response status:', error.response.status);
                        const responseText = await error.response.text();
                        console.error('ğŸš¨ Response text:', responseText);
                    }
                } catch (responseError) {
                    console.error('ğŸš¨ Response error handling failed:', responseError);
                }
            } finally {
                $btnAnalyze.disabled = false;
                updateButtons();
            }
            };
            
            // ğŸ›¡ï¸ ì•ˆì „í•œ Promise ì²˜ë¦¬ - unhandledrejection ë°©ì§€
            analyzeAsync().then(function() {
                console.log("âœ… ë¶„ì„ ì™„ë£Œ");
            }).catch(function(error) {
                console.error('ğŸš¨ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬ëœ ì˜¤ë¥˜:', error);
                $status.textContent = "âŒ ë¶„ì„ ì‹¤íŒ¨: " + (error.message || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜");
            });
        };
    }

    // Microphone button handler
    if ($btnMic) {
        $btnMic.onclick = async () => {
            // ğŸ¯ ìŒë†’ì´ í•™ìŠµì¸ ê²½ìš° ì°¸ì¡° ìŒì„± ì²´í¬ ìƒëµ
            if (learningMethod !== 'pitch' && !refCurve.length) {
                alert('ë¨¼ì € ì°¸ì¡° ìŒì„±ì„ ë¶„ì„í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            // If recording, stop it
            if (started) {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                
                if (procNode) {
                    procNode.disconnect();
                    procNode = null;
                }
                
                if (audioCtx) {
                    audioCtx.close();
                    audioCtx = null;
                }
                
                started = false;
                $btnMic.innerHTML = '<i class="fas fa-microphone me-2"></i> ì–µì–‘ ì—°ìŠµ ì‹œì‘';
                $btnMic.classList.remove('btn-danger');
                $btnMic.classList.add('btn-success');
                
                // Calculate pronunciation score
                const score = calculatePronunciationScore();
                updateLearningProgress(4, score);
                
                $status.textContent = `ğŸ‰ ì–µì–‘ ì—°ìŠµ ì™„ë£Œ! ì–µì–‘ ì ìˆ˜: ${score}ì  - ${score >= 80 ? 'ìš°ìˆ˜í•©ë‹ˆë‹¤!' : score >= 60 ? 'ì¢‹ìŠµë‹ˆë‹¤! ë” ì—°ìŠµí•´ë³´ì„¸ìš”.' : 'ë” ì—°ìŠµì´ í•„ìš”í•©ë‹ˆë‹¤.'}`;
                
                updateButtons();
                return;
            }
            
            try {
                $status.textContent = "ë§ˆì´í¬ ê¶Œí•œì„ ìš”ì²­ ì¤‘...";
                
                // ğŸ¯ ì‚¬ìš© ê°€ëŠ¥í•œ ë§ˆì´í¬ ì¥ì¹˜ í™•ì¸
                console.log("ğŸ¤ ë§ˆì´í¬ ì¥ì¹˜ í™•ì¸ ì¤‘...");
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                
                console.log(`ğŸ¤ ë°œê²¬ëœ ë§ˆì´í¬ ì¥ì¹˜ ${audioInputs.length}ê°œ:`);
                audioInputs.forEach((device, index) => {
                    console.log(`  ${index + 1}. ${device.label || `ë§ˆì´í¬ ${index + 1}`} (ID: ${device.deviceId.slice(0, 20)}...)`);
                });
                
                // USB ë§ˆì´í¬ ìš°ì„  ì„ íƒ
                let selectedDeviceId = null;
                const usbMic = audioInputs.find(device => 
                    device.label.toLowerCase().includes('usb') || 
                    device.label.toLowerCase().includes('external')
                );
                
                if (usbMic) {
                    selectedDeviceId = usbMic.deviceId;
                    console.log("ğŸ¤ USB ë§ˆì´í¬ ì„ íƒ:", usbMic.label);
                    $status.textContent = `USB ë§ˆì´í¬ ì—°ê²° ì¤‘: ${usbMic.label}`;
                } else {
                    console.log("ğŸ¤ USB ë§ˆì´í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ ê¸°ë³¸ ë§ˆì´í¬ ì‚¬ìš©");
                    $status.textContent = "ê¸°ë³¸ ë§ˆì´í¬ë¡œ ì—°ê²° ì¤‘...";
                }
                
                const constraints = {
                    audio: {
                        sampleRate: cfg.sampleRate,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                };
                
                // íŠ¹ì • ì¥ì¹˜ IDê°€ ìˆìœ¼ë©´ ì¶”ê°€
                if (selectedDeviceId) {
                    constraints.audio.deviceId = { exact: selectedDeviceId };
                }
                
                console.log("ğŸ¤ ë§ˆì´í¬ ì ‘ê·¼ ìš”ì²­:", constraints);
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // ì‹¤ì œ ì‚¬ìš© ì¤‘ì¸ ì¥ì¹˜ í™•ì¸
                const tracks = stream.getAudioTracks();
                if (tracks.length > 0) {
                    const settings = tracks[0].getSettings();
                    console.log("ğŸ¤ ì‹¤ì œ ì‚¬ìš© ì¤‘ì¸ ë§ˆì´í¬:", tracks[0].label);
                    console.log("ğŸ¤ ë§ˆì´í¬ ì„¤ì •:", settings);
                    $status.textContent = `ë§ˆì´í¬ ì—°ê²°ë¨: ${tracks[0].label}`;
                }
                
                // Setup MediaRecorder for audio recording
                recordedChunks = [];
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    recordedAudioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    console.log('Recording saved, size:', recordedAudioBlob.size, 'bytes');
                    updateButtons();
                };
                
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: cfg.sampleRate
                });
                
                // AudioContext ì¬ê°œ (Chrome ì •ì±…)
                if (audioCtx.state === 'suspended') {
                    await audioCtx.resume();
                    console.log("ğŸ¤ AudioContext ì¬ê°œë¨");
                }
                
                const src = audioCtx.createMediaStreamSource(stream);
                const bufSize = 4096; // ë” í° ë²„í¼ë¡œ ì•ˆì •ì„± í–¥ìƒ
                const frameSize = Math.round(cfg.sampleRate * (cfg.frameMs / 1000));
                const hopSize = Math.round(cfg.sampleRate * (cfg.hopMs / 1000));
                
                console.log(`ğŸ¤ ì˜¤ë””ì˜¤ ì„¤ì •: bufSize=${bufSize}, frameSize=${frameSize}, hopSize=${hopSize}`);
                
                const proc = audioCtx.createScriptProcessor(bufSize, 1, 1);
                
                const ring = new Float32Array(frameSize * 2);
                let ringPos = 0, accTime = 0;
                
                // ì—°ê²° ì „ì— ë¡œê·¸ í™•ì¸
                console.log("ğŸ¤ ì˜¤ë””ì˜¤ ë…¸ë“œ ì—°ê²° ì¤‘...");
                src.connect(proc);
                proc.connect(audioCtx.destination);
                console.log("ğŸ¤ ì˜¤ë””ì˜¤ ë…¸ë“œ ì—°ê²° ì™„ë£Œ");
                
                // Start recording
                mediaRecorder.start();
                
                started = true;
                sylCuts = [];
                tLive = 0;
                liveBuffer = [];
                
                // ìŒì ˆ ì¶”ì  ì´ˆê¸°í™”
                currentSyllableIndex = 0;
                syllableStartTime = 0;
                
                $status.textContent = "ğŸ¤ ì‹¤ì‹œê°„ ìŒì„± ë¶„ì„ ì¤‘... ì°¸ì¡° ìŒì„±ê³¼ ë™ì¼í•œ ë‚´ìš©ì„ ë°œí™”í•´ ì£¼ì„¸ìš”.";
                $btnMic.innerHTML = '<i class="fas fa-stop me-1"></i> ë…¹ìŒ ì¤‘ì§€';
                $btnMic.classList.remove('btn-success');
                $btnMic.classList.add('btn-danger');
                $btnMic.disabled = false;
                
                // ì˜¤ë””ì˜¤ ì²˜ë¦¬ í•¸ë“¤ëŸ¬ ì„¤ì •
                console.log("ğŸ¤ ì˜¤ë””ì˜¤ ì²˜ë¦¬ í•¸ë“¤ëŸ¬ ì„¤ì • ì¤‘...");
                
                proc.onaudioprocess = (e) => {
                    try {
                        if (!e || !e.inputBuffer) {
                            console.error("ğŸ¤ ì…ë ¥ ë²„í¼ê°€ ì—†ìŠµë‹ˆë‹¤!");
                            return;
                        }
                        
                        const ch = e.inputBuffer.getChannelData(0);
                        if (!ch || ch.length === 0) {
                            console.error("ğŸ¤ ì±„ë„ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤!");
                            return;
                        }
                        
                        // ğŸ¯ ì˜¤ë””ì˜¤ ì…ë ¥ ë ˆë²¨ í™•ì¸
                        let maxLevel = 0;
                        for (let i = 0; i < ch.length; i++) {
                            maxLevel = Math.max(maxLevel, Math.abs(ch[i]));
                        }
                        
                        // ì£¼ê¸°ì ìœ¼ë¡œë§Œ ë¡œê·¸ (ë„ˆë¬´ ë§ì€ ë¡œê·¸ ë°©ì§€)
                        if (Math.random() < 0.1) { // 10%ë§Œ ë¡œê·¸
                            console.log(`ğŸ¤ ì˜¤ë””ì˜¤ ë ˆë²¨: ${(maxLevel * 100).toFixed(1)}%`);
                        }
                        
                        // ë„ˆë¬´ ì‘ì€ ì‹ í˜¸ëŠ” ë¬´ì‹œ
                        if (maxLevel < 0.001) {
                            return;
                        }
                        
                        // Fill ring buffer
                        for (let i = 0; i < ch.length; i++) {
                            ring[ringPos % ring.length] = ch[i];
                            ringPos++;
                        }
                        
                        accTime += ch.length / audioCtx.sampleRate;
                        
                        // ğŸš€ ì‹¤ì‹œê°„ ì²˜ë¦¬: ë” ìì£¼ í”„ë ˆì„ ì²˜ë¦¬ (ì§€ì—° ìµœì†Œí™”)
                        while (accTime >= (cfg.hopMs / 1000 / 2)) { // 2ë°° ë¹ ë¥¸ ì²˜ë¦¬
                            accTime -= (cfg.hopMs / 1000 / 2);
                            
                            const frame = new Float32Array(frameSize);
                            const start = (ringPos - frameSize + ring.length) % ring.length;
                            
                            for (let j = 0; j < frameSize; j++) {
                                frame[j] = ring[(start + j) % ring.length];
                            }
                            
                            // Analyze frame
                            // ğŸ¯ í”„ë ˆì„ ë°ì´í„°ë¥¼ ë°±ì—”ë“œ Praat ë¶„ì„ìœ¼ë¡œ ì „ì†¡ (ë” ì •í™•í•¨)
                            if (frame.length > 0) {
                                sendFrameToBackend(frame, audioCtx.sampleRate);
                            }
                            
                            // ğŸ”¥ ê¸°ì¡´ JavaScript YIN ëŒ€ì‹  ë°±ì—”ë“œ Praat ì‚¬ìš©
                            // const f0 = yinPitch(frame, audioCtx.sampleRate);
                            // const dB = frameEnergy(frame);
                            
                            // // ìœ íš¨í•œ í”¼ì¹˜ë§Œ ì²˜ë¦¬
                            // if (f0 > 0 && f0 < 1000) { // 1000Hz ì´í•˜ë§Œ ìœ íš¨
                                // ğŸ¯ í˜„ì¬ Yì¶• ë‹¨ìœ„ì— ë§ê²Œ ë³€í™˜
                                let yValue;
                                if (currentYAxisUnit === 'qtone') {
                                    yValue = f0ToQt(f0);
                                } else {
                                    yValue = f0ToSemitone(f0, refMedian);
                                }
                                
                                const intN = normInt(dB);
                                
                                tLive += (cfg.hopMs / 1000);
                                liveBuffer.push({x: tLive, y: yValue, int: intN});
                                
                                // Syllable tracking
                                vadSyllableTracker(dB, tLive);
                                
                                // Time warp and render (ìŒì ˆë³„ ë™ê¸°í™”)  
                                const warped = syllableBasedTimeWarp(liveBuffer);
                                
                                // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
                                chart.data.datasets[1].data = warped.map(p => ({x: p.x, y: p.y}));
                                chart.data.datasets[2].data = warped.map(p => ({x: p.x, y: p.int}));
                                // ğŸš€ ì´ˆê³ ì† ì°¨íŠ¸ ì—…ë°ì´íŠ¸ (ì• ë‹ˆë©”ì´ì…˜ ì™„ì „ ë¹„í™œì„±í™”)
                                chart.update('none'); // ì´ë¯¸ ìµœì í™”ë¨
                                
                                // ğŸš€ ë¡œê·¸ ìµœì†Œí™” (ì„±ëŠ¥ í–¥ìƒ)
                                if (Math.random() < 0.01) { // 1%ë§Œ ë¡œê·¸ (ì„±ëŠ¥ ìµœì í™”)
                                    let unitLabel = currentYAxisUnit === 'qtone' ? 'qt' : 'st';
                                    console.log(`ğŸ¤ ${f0.toFixed(0)}Hzâ†’${yValue.toFixed(1)}${unitLabel}`);
                                }
                            }
                            
                            // ë²„í¼ í¬ê¸° ì œí•œ (ë©”ëª¨ë¦¬ ì ˆì•½)
                            if (liveBuffer.length > 1000) {
                                liveBuffer = liveBuffer.slice(-500);
                            }
                        }
                        
                    } catch (error) {
                        console.error("ğŸ¤ ì˜¤ë””ì˜¤ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
                    }
                };
                
                console.log("ğŸ¤ ì˜¤ë””ì˜¤ ì²˜ë¦¬ í•¸ë“¤ëŸ¬ ì„¤ì • ì™„ë£Œ");
                
                procNode = proc;
                
            } catch (e) {
                console.error('ğŸ¤ ë§ˆì´í¬ ì˜¤ë¥˜:', e);
                
                let errorMsg = "ë§ˆì´í¬ ì ‘ê·¼ ì‹¤íŒ¨: ";
                if (e.name === 'NotAllowedError') {
                    errorMsg += "ë¸Œë¼ìš°ì €ì—ì„œ ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ ì£¼ì„¸ìš”.";
                } else if (e.name === 'NotFoundError') {
                    errorMsg += "ë§ˆì´í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. USB ë§ˆì´í¬ê°€ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.";
                } else if (e.name === 'NotReadableError') {
                    errorMsg += "ë§ˆì´í¬ê°€ ë‹¤ë¥¸ ì•±ì—ì„œ ì‚¬ìš© ì¤‘ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
                } else if (e.name === 'OverconstrainedError') {
                    errorMsg += "USB ë§ˆì´í¬ê°€ ì§€ì›ë˜ì§€ ì•ŠëŠ” ì„¤ì •ì…ë‹ˆë‹¤. ê¸°ë³¸ ë§ˆì´í¬ë¡œ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.";
                    
                    // USB ë§ˆì´í¬ ì„¤ì •ì´ ì‹¤íŒ¨í•˜ë©´ ê¸°ë³¸ ë§ˆì´í¬ë¡œ ì¬ì‹œë„
                    try {
                        console.log("ğŸ¤ ê¸°ë³¸ ë§ˆì´í¬ë¡œ ì¬ì‹œë„...");
                        const basicStream = await navigator.mediaDevices.getUserMedia({
                            audio: {
                                sampleRate: cfg.sampleRate,
                                channelCount: 1,
                                echoCancellation: false,
                                noiseSuppression: false,
                                autoGainControl: false
                            }
                        });
                        
                        // ì„±ê³µí•˜ë©´ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ ê³„ì†
                        console.log("ğŸ¤ ê¸°ë³¸ ë§ˆì´í¬ ì—°ê²° ì„±ê³µ!");
                        $status.textContent = "ê¸°ë³¸ ë§ˆì´í¬ë¡œ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.";
                        
                        // ì—¬ê¸°ì„œ ì›ë˜ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ ì½”ë“œë¥¼ ê³„ì† ì‹¤í–‰í•´ì•¼ í•¨
                        // í•˜ì§€ë§Œ ì½”ë“œ ì¤‘ë³µì„ í”¼í•˜ê¸° ìœ„í•´ ë³„ë„ í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•˜ëŠ” ê²ƒì´ ì¢‹ìŒ
                        
                        return; // ì¬ì‹œë„ ì„±ê³µ ì‹œ ì—ëŸ¬ ì²˜ë¦¬ ì¤‘ë‹¨
                    } catch (retryError) {
                        errorMsg += " ê¸°ë³¸ ë§ˆì´í¬ë„ ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
                    }
                } else {
                    errorMsg += e.message;
                }
                
                $status.textContent = errorMsg;
                started = false;
                $btnMic.innerHTML = '<i class="fas fa-microphone me-1"></i> ë§ˆì´í¬ ë…¹ìŒ';
                $btnMic.classList.remove('btn-danger');
                $btnMic.classList.add('btn-success');
                updateButtons();
            }
        };
    }

    // Chart Clear button handler
    if ($btnClearChart) {
        $btnClearChart.onclick = () => {
            console.log("ğŸ¯ ì°¨íŠ¸ ì´ˆê¸°í™” ì‹œì‘...");
            
            // Clear chart data only
            chart.data.datasets[0].data = [];  // Reference data
            chart.data.datasets[1].data = [];  // Live data
            chart.data.datasets[2].data = [];  // Intensity data
            
            // Clear pitch test data if exists
            if (chart.data.datasets[3]) {
                chart.data.datasets[3].data = [];
            }
            // Clear red point data (ìŒë†’ì´ í…ŒìŠ¤íŠ¸ ì „ìš©)
            if (chart.data.datasets[4]) {
                chart.data.datasets[4].data = [];
            }
            
            // Clear current pitch line annotation
            if (chart.options.plugins.annotation && chart.options.plugins.annotation.annotations.currentPitchLine) {
                delete chart.options.plugins.annotation.annotations.currentPitchLine;
            }
            
            // ğŸ§¹ ëª¨ë“  annotation ì™„ì „ ì œê±° (ì•ˆì „í•œ ë°©ì‹)
            if (chart && chart.options && chart.options.plugins && chart.options.plugins.annotation) {
                chart.options.plugins.annotation.annotations = {};
                chart.update('none');
                console.log("ğŸ§¹ ì°¨íŠ¸ ì´ˆê¸°í™” - ìŒì ˆ í‘œì‹œ ì œê±° ì™„ë£Œ");
            }
            
            // ğŸ¯ í”¼ì¹˜ í…ŒìŠ¤íŠ¸ ìƒíƒœ ì´ˆê¸°í™”
            targetPitch = null;
            pitchTestLine = null;
            
            // Reset analysis data
            refCurve = [];
            refSyll = [];
            refStats = {meanF0: 0, maxF0: 0, duration: 0};
            liveBuffer = [];
            
            // Update chart
            chart.update();
            console.log("ğŸ¯ ì°¨íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ!");
            
            // Update status
            $status.textContent = "ì°¨íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ìƒˆë¡œìš´ ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.";
            
            // Update buttons
            updateButtons();
            updatePitchTestButtons();
            
            // í”¼ì¹˜ í…ŒìŠ¤íŠ¸ ìƒíƒœ ë©”ì‹œì§€ ì´ˆê¸°í™”
            if ($pitchTestStatus) {
                $pitchTestStatus.textContent = "ì°¨íŠ¸ì—ì„œ ì—°ìŠµí•  ìŒë†’ì´ë¥¼ í´ë¦­í•˜ì„¸ìš”";
                $pitchTestStatus.className = "text-center text-danger small fw-bold";
            }
        };
    }

    // Range update button handler
    if ($btnUpdateRange) {
        $btnUpdateRange.onclick = () => {
            const minVal = parseFloat($semitoneMin.value);
            const maxVal = parseFloat($semitoneMax.value);
            if (minVal < maxVal) {
                updateChartRange(minVal, maxVal);
            } else {
                alert('ìµœì†Œê°’ì€ ìµœëŒ€ê°’ë³´ë‹¤ ì‘ì•„ì•¼ í•©ë‹ˆë‹¤.');
            }
        };
    }

    // Reset button handler  
    if ($btnReset) {
        $btnReset.onclick = () => {
            // Stop recording if in progress
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
            
            if (procNode) {
                try {
                    procNode.disconnect();
                } catch (e) {
                    console.error('Error disconnecting processor:', e);
                }
            }
            
            if (audioCtx) {
                try {
                    audioCtx.close();
                } catch (e) {
                    console.error('Error closing audio context:', e);
                }
            }
            
            // Stop any playing audio
            stopAllAudio();
            
            // Reset audio data
            refAudioBlob = null;
            recordedAudioBlob = null;
            recordedChunks = [];
            
            liveBuffer = [];
            sylCuts = [];
            started = false;
            tLive = 0;
            liveStats = {meanF0: 0, maxF0: 0};
            
            // Reset microphone button
            if ($btnMic) {
                $btnMic.innerHTML = '<i class="fas fa-microphone me-1"></i> ë§ˆì´í¬ ë…¹ìŒ';
                $btnMic.classList.remove('btn-danger');
                $btnMic.classList.add('btn-success');
            }
            
            chart.data.datasets[1].data = [];
            chart.data.datasets[2].data = [];
            
            // Clear syllable annotations
            if (chart.options.plugins.annotation) {
                chart.options.plugins.annotation.annotations = {};
            }
            
            chart.update();
            
            $status.textContent = "ì´ˆê¸°í™” ì™„ë£Œ. ìƒˆë¡œìš´ ë¶„ì„ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
            
            updateButtons();
        };
    }

    // Audio playback handlers
    if ($btnPlayRef) {
        $btnPlayRef.onclick = playReferenceAudio;
    }
    
    if ($btnPlayRec) {
        $btnPlayRec.onclick = playRecordedAudio;
    }
    
    if ($btnReplayPractice) {
        $btnReplayPractice.onclick = function() { replayPracticeSession(); };
    }
    
    // Load saved files list
    loadSavedFilesList();
    
    // Saved files selection handler
    if ($savedFiles) {
        $savedFiles.onchange = () => {
            loadSelectedFile();
            updateDeleteButtonState();
        };
    }
    
    // Delete saved file handler
    if ($btnDeleteSaved) {
        $btnDeleteSaved.onclick = confirmDeleteSavedFile;
    }
    
    // Save reference button
    if ($btnSaveReference) {
        $btnSaveReference.onclick = showSaveModal;
    }
}

// Audio playback functions
function stopAllAudio() {
    if (currentlyPlaying) {
        currentlyPlaying.pause();
        currentlyPlaying = null;
    }
}

function playReferenceAudio() {
    if (!$wav || !$wav.files || $wav.files.length === 0) {
        console.log('No reference audio file available');
        return;
    }
    
    stopAllAudio();
    
    const audioFile = $wav.files[0];
    const audioUrl = URL.createObjectURL(audioFile);
    const audio = new Audio(audioUrl);
    
    audio.onplay = () => {
        currentlyPlaying = audio;
        $btnPlayRef.innerHTML = '<i class="fas fa-stop me-1"></i> ì°¸ì¡°ìŒì„± ì •ì§€';
        $btnPlayRef.classList.remove('btn-info');
        $btnPlayRef.classList.add('btn-danger');
    };
    
    audio.onended = audio.onpause = () => {
        currentlyPlaying = null;
        $btnPlayRef.innerHTML = '<i class="fas fa-play me-1"></i> ì°¸ì¡°ìŒì„± ì¬ìƒ';
        $btnPlayRef.classList.remove('btn-danger');
        $btnPlayRef.classList.add('btn-info');
        URL.revokeObjectURL(audioUrl);
    };
    
    audio.onerror = () => {
        console.error('Error playing reference audio');
        $status.textContent = 'ì°¸ì¡° ìŒì„± ì¬ìƒ ì˜¤ë¥˜';
        currentlyPlaying = null;
        $btnPlayRef.innerHTML = '<i class="fas fa-play me-1"></i> ì°¸ì¡°ìŒì„± ì¬ìƒ';
        $btnPlayRef.classList.remove('btn-danger');
        $btnPlayRef.classList.add('btn-info');
        URL.revokeObjectURL(audioUrl);
    };
    
    if (currentlyPlaying === audio) {
        audio.pause();
        currentlyPlaying = null;
    } else {
        audio.play().catch(e => {
            console.error('Error playing audio:', e);
            $status.textContent = 'ìŒì„± ì¬ìƒ ì˜¤ë¥˜';
        });
    }
}

function playRecordedAudio() {
    if (!recordedAudioBlob) {
        console.log('No recorded audio available');
        return;
    }
    
    stopAllAudio();
    
    const audioUrl = URL.createObjectURL(recordedAudioBlob);
    const audio = new Audio(audioUrl);
    
    audio.onplay = () => {
        currentlyPlaying = audio;
        $btnPlayRec.innerHTML = '<i class="fas fa-stop me-1"></i> ë…¹ìŒìŒì„± ì •ì§€';
        $btnPlayRec.classList.remove('btn-warning');
        $btnPlayRec.classList.add('btn-danger');
    };
    
    audio.onended = audio.onpause = () => {
        currentlyPlaying = null;
        $btnPlayRec.innerHTML = '<i class="fas fa-play me-1"></i> ë…¹ìŒìŒì„± ì¬ìƒ';
        $btnPlayRec.classList.remove('btn-danger');
        $btnPlayRec.classList.add('btn-warning');
        URL.revokeObjectURL(audioUrl);
    };
    
    audio.onerror = () => {
        console.error('Error playing recorded audio');
        $status.textContent = 'ë…¹ìŒ ìŒì„± ì¬ìƒ ì˜¤ë¥˜';
        currentlyPlaying = null;
        $btnPlayRec.innerHTML = '<i class="fas fa-play me-1"></i> ë…¹ìŒìŒì„± ì¬ìƒ';
        $btnPlayRec.classList.remove('btn-danger');
        $btnPlayRec.classList.add('btn-warning');
        URL.revokeObjectURL(audioUrl);
    };
    
    if (currentlyPlaying === audio) {
        audio.pause();
        currentlyPlaying = null;
    } else {
        audio.play().catch(e => {
            console.error('Error playing audio:', e);
            $status.textContent = 'ìŒì„± ì¬ìƒ ì˜¤ë¥˜';
        });
    }
}

// Add event listeners with better error handling  
console.log('ToneBridge audio-analysis.js loaded');

// ğŸ¯ í˜„ì¬ Yì¶• ë‹¨ìœ„ (semitone ë˜ëŠ” qtone)
let currentYAxisUnit = 'semitone';

// ğŸ§ ì‹¤ì‹œê°„ í”¼ë“œë°±ì„ ìœ„í•œ ì´ˆê³ ê°ë„ ì„ê³„ê°’ - ì¦‰ê°ì ì¸ ë°˜ì‘ì„± ìš°ì„ 
const PERCEPTUAL_THRESHOLDS = {
    'semitone': 0.05,  // 0.05 ì„¸ë¯¸í†¤ - ì´ˆê³ ê°ë„ (ì¦‰ê° ë°˜ì‘)
    'qtone': 0.1       // 0.1 Q-tone - ì´ˆê³ ê°ë„ (ì¦‰ê° ë°˜ì‘)
};

// ğŸµ ì´ì „ í”¼ì¹˜ ê°’ (í•„í„°ë§ìš©)
let lastPerceptiblePitch = null;

// ğŸ¬ ì‹¤ì‹œê°„ ì—°ìŠµ ì‹œê°í™” ì €ì¥/ì¬ìƒ ê¸°ëŠ¥
let practiceRecordingData = []; // ì—°ìŠµ ì¤‘ ì‹¤ì‹œê°„ ë°ì´í„° ì €ì¥
let isRecordingPractice = false; // ì—°ìŠµ ë°ì´í„° ì €ì¥ ì¤‘ì¸ì§€ ì—¬ë¶€
let replayInterval = null; // ì¬ìƒ íƒ€ì´ë¨¸

// ğŸ¬ ì—°ìŠµ ì„¸ì…˜ ì¬ìƒ ê¸°ëŠ¥
function replayPracticeSession() {
    if (!practiceRecordingData || practiceRecordingData.length === 0) {
        alert('ì €ì¥ëœ ì—°ìŠµ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
        return;
    }
    
    if (replayInterval) {
        // ì¬ìƒ ì¤‘ì§€
        clearInterval(replayInterval);
        replayInterval = null;
        $btnReplayPractice.innerHTML = '<i class="fas fa-history me-1"></i> ì—°ìŠµ ì¬ìƒ';
        $btnReplayPractice.classList.remove('btn-danger');
        $btnReplayPractice.classList.add('btn-warning');
        
        // ë¼ì´ë¸Œ ë°ì´í„° ì°¨íŠ¸ í´ë¦¬ì–´ 
        if (chart && chart.data.datasets[1]) {
            chart.data.datasets[1].data = [];
            chart.update('none');
        }
        return;
    }
    
    // ì¬ìƒ ì‹œì‘
    console.log(`ğŸ¬ ì—°ìŠµ ì¬ìƒ ì‹œì‘: ${practiceRecordingData.length}ê°œ í¬ì¸íŠ¸`);
    
    // ë²„íŠ¼ ìƒíƒœ ë³€ê²½
    $btnReplayPractice.innerHTML = '<i class="fas fa-stop me-1"></i> ì¬ìƒ ì¤‘ì§€';
    $btnReplayPractice.classList.remove('btn-warning');
    $btnReplayPractice.classList.add('btn-danger');
    
    // ì¬ìƒìš© ì„ì‹œ ë°ì´í„°
    const replayData = [];
    let currentIndex = 0;
    
    // ì‹œì‘ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”
    const startTime = practiceRecordingData[0].time;
    const endTime = practiceRecordingData[practiceRecordingData.length - 1].time;
    const duration = endTime - startTime;
    
    console.log(`ğŸ¬ ì¬ìƒ ì‹œê°„: ${duration.toFixed(1)}ì´ˆ`);
    
    // ì¬ìƒ íƒ€ì´ë¨¸ (50ms ê°„ê²©ìœ¼ë¡œ ì¬ìƒ)
    replayInterval = setInterval(() => {
        if (currentIndex >= practiceRecordingData.length) {
            // ì¬ìƒ ì™„ë£Œ
            clearInterval(replayInterval);
            replayInterval = null;
            $btnReplayPractice.innerHTML = '<i class="fas fa-history me-1"></i> ì—°ìŠµ ì¬ìƒ';
            $btnReplayPractice.classList.remove('btn-danger');
            $btnReplayPractice.classList.add('btn-warning');
            console.log('ğŸ¬ ì—°ìŠµ ì¬ìƒ ì™„ë£Œ');
            return;
        }
        
        // í˜„ì¬ í¬ì¸íŠ¸ë¥¼ ì°¨íŠ¸ì— ì¶”ê°€
        const currentPoint = practiceRecordingData[currentIndex];
        replayData.push({
            x: currentPoint.time,
            y: currentPoint.pitch
        });
        
        // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        if (chart && chart.data.datasets[1]) {
            chart.data.datasets[1].data = [...replayData];
            chart.update('none');
        }
        
        currentIndex++;
        
        // ì§„í–‰ ìƒí™© ë¡œê·¸ (ê°€ë”ì”©ë§Œ)
        if (currentIndex % 20 === 0) {
            const progress = ((currentIndex / practiceRecordingData.length) * 100).toFixed(1);
            console.log(`ğŸ¬ ì¬ìƒ ì§„í–‰: ${progress}%`);
        }
    }, 50); // 50ms ê°„ê²©ìœ¼ë¡œ ì¬ìƒ (ë¶€ë“œëŸ¬ìš´ ì¬ìƒ)
}

// ğŸ¯ Yì¶• ë‹¨ìœ„ í† ê¸€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
function setupYAxisToggle() {
    const semitoneRadio = document.getElementById('yAxisSemitone');
    const qtoneRadio = document.getElementById('yAxisQtone');
    
    if (semitoneRadio) {
        semitoneRadio.addEventListener('change', function() {
            if (this.checked) {
                currentYAxisUnit = 'semitone';
                lastPerceptiblePitch = null; // ë‹¨ìœ„ ë³€ê²½ ì‹œ í•„í„°ë§ ì´ˆê¸°í™”
                updateChartYAxis();
            }
        });
    }
        
    if (qtoneRadio) {
        qtoneRadio.addEventListener('change', function() {
            if (this.checked) {
                currentYAxisUnit = 'qtone';
                lastPerceptiblePitch = null; // ë‹¨ìœ„ ë³€ê²½ ì‹œ í•„í„°ë§ ì´ˆê¸°í™”
                updateChartYAxis();
            }
        });
    }
        
    console.log('ğŸ¯ Yì¶• ë‹¨ìœ„ í† ê¸€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì™„ë£Œ');
}

// ğŸ¯ ì°¨íŠ¸ Yì¶• ì—…ë°ì´íŠ¸
function updateChartYAxis() {
    if (!chart) return;
    
    const refFreq = refMedian || 200;
    let minValue, maxValue;
    
    if (currentYAxisUnit === 'qtone') {
        // Q-tone ê¸°ë³¸ ë²”ìœ„: 0~25 ë“±ê¸‰ ì „ì²´ ì‚¬ìš©
        minValue = 0;
        maxValue = 25;
        
        // Input í•„ë“œë¥¼ Q-tone ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸
        $semitoneMin.value = Math.round(minValue * 10) / 10;
        $semitoneMax.value = Math.round(maxValue * 10) / 10;
        
        // ë‹¨ìœ„ í‘œì‹œë¥¼ "qt"ë¡œ ë³€ê²½
        const unitLabel = document.querySelector('small.text-muted:nth-of-type(3)');
        if (unitLabel) unitLabel.textContent = 'qt';
        
        chart.options.scales.y.min = minValue;
        chart.options.scales.y.max = maxValue;
        chart.options.scales.y.title.text = 'Q-tone (0~25 ë“±ê¸‰, ê¸°ì¤€: 200Hz=12qt)';
        
    } else {
        // Semitone ê¸°ë³¸ ë²”ìœ„: -6 ~ 12 ì„¸ë¯¸í†¤ (ê¸°ì¡´ ê¸°ë³¸ê°’ ìœ ì§€)
        minValue = parseFloat($semitoneMin.value) || -6;
        maxValue = parseFloat($semitoneMax.value) || 12;
        
        // Input í•„ë“œë¥¼ Semitone ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸
        $semitoneMin.value = Math.round(minValue);
        $semitoneMax.value = Math.round(maxValue);
        
        // ë‹¨ìœ„ í‘œì‹œë¥¼ "st"ë¡œ ë³€ê²½
        const unitLabel = document.querySelector('small.text-muted:nth-of-type(3)');
        if (unitLabel) unitLabel.textContent = 'st';
        
        chart.options.scales.y.min = minValue;
        chart.options.scales.y.max = maxValue;
        chart.options.scales.y.title.text = 'Semitone (ê¸°ì¤€: 200Hz)';
    }
    
    // ğŸ¯ Yì¶• ë‹¨ìœ„ ë³€ê²½ ì‹œ ì°¸ì¡° ë°ì´í„°ë¥¼ ìƒˆë¡œìš´ ë‹¨ìœ„ë¡œ ë³€í™˜í•˜ì—¬ í‘œì‹œ
    if (refCurve && refCurve.length > 0) {
        updateChartWithReferenceData();
    }
    
    chart.update();
    console.log(`ğŸ¯ Yì¶• ë‹¨ìœ„ ë³€ê²½: ${currentYAxisUnit}, ë²”ìœ„: ${minValue.toFixed(1)} ~ ${maxValue.toFixed(1)}`);
}

// ğŸ¯ ì°¸ì¡° ë°ì´í„°ë¡œ ì°¨íŠ¸ ì—…ë°ì´íŠ¸ (Yì¶• ë‹¨ìœ„ ë³€ê²½ì— ëŒ€ì‘)
function updateChartWithReferenceData() {
    if (!chart || !refCurve || refCurve.length === 0) return;
    
    // ğŸ¯ ì°¸ì¡° ê³¡ì„  ë°ì´í„°ë¥¼ í˜„ì¬ Yì¶• ë‹¨ìœ„ë¡œ ë³€í™˜
    const convertedRefData = refCurve.map(point => {
        let yValue;
        if (currentYAxisUnit === 'qtone') {
            // f0ë¥¼ Q-toneìœ¼ë¡œ ë³€í™˜ (ì‹¤ì œ refCurve êµ¬ì¡° ì‚¬ìš©)
            yValue = f0ToQt(point.f0);
        } else {
            // f0ë¥¼ semitoneìœ¼ë¡œ ë³€í™˜ (ì´ë¯¸ semitone ê°’ì´ ìˆìœ¼ë©´ ì‚¬ìš©)
            yValue = point.semitone || f0ToSemitone(point.f0, refMedian || 200);
        }
        return { x: point.t, y: yValue };  // refCurveì˜ ì‹¤ì œ ì†ì„±ëª… ì‚¬ìš©: t, f0, semitone
    });
    
    // ğŸ¯ ì°¨íŠ¸ì— ë³€í™˜ëœ ë°ì´í„° ì ìš©
    if (chart.data.datasets[0]) {
        chart.data.datasets[0].data = convertedRefData;
    }
    
    console.log(`ğŸ¯ ì°¸ì¡° ë°ì´í„° Yì¶• ë‹¨ìœ„ ë³€í™˜ ì™„ë£Œ: ${convertedRefData.length}ê°œ í¬ì¸íŠ¸`);
}


document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM Content Loaded - initializing...');
    
    // Initialize DOM elements
    initializeElements();
    
    // Setup all event handlers
    setupEventHandlers();
    
    // Setup Y-axis unit toggle
    setupYAxisToggle();
    
    // Initial button state
    setTimeout(updateButtons, 100);
});

// ğŸ¯ ìŠ¤í™íŠ¸ë¡œê·¸ë¨ ë°°ê²½ ë Œë”ë§ í•¨ìˆ˜ (ì‚¬ìš©ì ìš”ì²­)
function renderSpectrogramOnCanvas(chartInstance, spectrogramDataArray) {
    if (!spectrogramDataArray || spectrogramDataArray.length === 0) return;
    
    const ctx = chartInstance.ctx;
    const chartArea = chartInstance.chartArea;
    const xScale = chartInstance.scales.x;
    const yScale = chartInstance.scales.y;
    
    console.log(`ğŸ¯ ìº”ë²„ìŠ¤ì— ìŠ¤í™íŠ¸ë¡œê·¸ë¨ ê·¸ë¦¬ê¸°: ${spectrogramDataArray.length}ê°œ ì‹œì `);
    
    // ìŠ¤í™íŠ¸ë¡œê·¸ë¨ ê·¸ë¦¬ê¸°
    for (let i = 0; i < spectrogramDataArray.length; i++) {
        const specPoint = spectrogramDataArray[i];
        const x = xScale.getPixelForValue(specPoint.t);
        
        if (x < chartArea.left || x > chartArea.right) continue;
        
        // ì£¼íŒŒìˆ˜ ëŒ€ì—­ë³„ë¡œ ìƒ‰ìƒ ê°•ë„ í‘œì‹œ
        if (specPoint.spec && specPoint.spec.length > 0) {
            const freqStep = (specPoint.freq_max || 1000) / specPoint.spec.length;
            const rectWidth = Math.max(3, (chartArea.right - chartArea.left) / spectrogramDataArray.length);
            
            for (let j = 0; j < specPoint.spec.length; j++) {
                const freq = j * freqStep;
                const intensity = specPoint.spec[j];
                
                // ì£¼íŒŒìˆ˜ê°€ Yì¶• ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                if (freq < yScale.min || freq > yScale.max) continue;
                
                const y = yScale.getPixelForValue(freq);
                const rectHeight = Math.max(2, Math.abs(freqStep * (chartArea.bottom - chartArea.top) / (yScale.max - yScale.min)));
                
                // dB ê°’ì„ ìƒ‰ìƒ ê°•ë„ë¡œ ë³€í™˜ (-80dB ~ 0dB -> 0 ~ 0.5)
                const alpha = Math.max(0, Math.min(0.5, (intensity + 80) / 80 * 0.5));
                
                // ìŠ¤í™íŠ¸ë¡œê·¸ë¨ ìƒ‰ìƒ (íŒŒë€ìƒ‰ ê³„ì—´) - ë” ì§„í•˜ê²Œ
                if (alpha > 0.1) {  // ë„ˆë¬´ ì•½í•œ ì‹ í˜¸ëŠ” í‘œì‹œí•˜ì§€ ì•ŠìŒ
                    ctx.fillStyle = `rgba(100, 150, 255, ${alpha})`;
                    ctx.fillRect(x - rectWidth/2, y - rectHeight/2, rectWidth, rectHeight);
                }
            }
        }
    }
}

// Fallback - if DOMContentLoaded already fired
if (document.readyState === 'loading') {
    // Do nothing, DOMContentLoaded will handle it
} else {
    console.log('Document already loaded, initializing immediately');
    setTimeout(function() {
        initializeElements();
        setupEventHandlers();
        setupYAxisToggle();
        updateButtons();
    }, 10);
}

// Initialize Chart.js with annotation plugin
// Register annotation plugin (it may be auto-registered via CDN)

// Chart.js annotation í”ŒëŸ¬ê·¸ì¸ì€ CDNì—ì„œ ìë™ ë“±ë¡ë¨

const chart = new Chart(document.getElementById('chart'), {
    type: "line",
    data: {
        datasets: [
            {
                label: "í‘œì¤€ ì–µì–‘ íŒ¨í„´",
                data: [],
                parsing: false,
                borderWidth: 1,
                pointRadius: 4,  // ğŸ¯ ìŒì ˆë³„ í¬ì¸íŠ¸ í¬ê¸° ì¡°ì •
                pointBackgroundColor: 'rgb(54, 162, 235)',
                pointBorderColor: 'white',
                pointBorderWidth: 2,
                tension: 0,  // ğŸ¯ ì§ì„  ì—°ê²°
                borderColor: 'rgb(54, 162, 235)',
                backgroundColor: 'rgba(54, 162, 235, 0.1)'
            },
            {
                label: "ë‚´ ìŒì„± ì–µì–‘",
                data: [],
                parsing: false,
                borderWidth: 2,
                pointRadius: 0,
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.1)'
            },
            {
                label: "ë°œì„± ê°•ë„",
                data: [],
                parsing: false,
                borderWidth: 1,
                pointRadius: 0,
                borderDash: [5, 5],
                borderColor: 'rgb(255, 205, 86)',
                backgroundColor: 'rgba(255, 205, 86, 0.1)',
                yAxisID: "y1"
            },
            {
                label: "ì‹¤ì‹œê°„ Hz",
                data: [],
                parsing: false,
                borderWidth: 2,
                pointRadius: 1,
                borderColor: 'rgb(255, 165, 0)',
                backgroundColor: 'rgba(255, 165, 0, 0.3)',
                yAxisID: "y1"
            },
            {
                label: "ğŸ”´ í˜„ì¬ ìŒë†’ì´",
                data: [],
                parsing: false,
                borderWidth: 0,
                pointRadius: 8,
                pointBackgroundColor: 'rgba(255, 0, 0, 0.8)',
                pointBorderColor: 'rgb(255, 255, 255)',
                pointBorderWidth: 2,
                yAxisID: "y",
                showLine: false
            }
        ]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: {
            legend: {
                position: 'top'
            },
            tooltip: {
                mode: 'index',
                intersect: false
            },
            annotation: {
                annotations: {}
            }
        },
        layout: {
            padding: 10
        },
        backgroundColor: '#ffffff',
        onClick: (event, activeElements, chart) => {
            // ğŸ¯ ì°¨íŠ¸ í´ë¦­ ì‹œ ìŒë†’ì´ í…ŒìŠ¤íŠ¸ ëª¨ë“œ
            handleChartClick(event, chart);
        },
        scales: {
            x: {
                type: 'linear',
                title: {
                    display: true,
                    text: 'ì‹œê°„ (ì´ˆ)',
                    font: {
                        size: 10
                    },
                    position: 'end',
                    align: 'end'
                }
            },
            y: {
                min: -6,
                max: 12,
                title: {
                    display: true,
                    text: 'Semitone (ë°˜ìŒê³„)'
                }
            },
            y1: {
                min: 80,
                max: 400,
                position: 'right',
                grid: {
                    drawOnChartArea: false
                },
                title: {
                    display: true,
                    text: 'ì‹¤ì‹œê°„ Hz'
                }
            }
        },
        interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
        },
        onHover: (evt, elements) => {
            // Mouse hover for range selection visual feedback
            if (!chart) return;
            
            const canvasPos = Chart.helpers.getRelativePosition(evt, chart);
            const dataY = chart.scales.y.getValueForPixel(canvasPos.y);
            
            if (isSelecting && rangeStart !== null) {
                // Show preview of selection range
                updateRangePreview(rangeStart, dataY);
            }
        },
        onClick: (evt, elements) => {
            if (!chart) return;
            
            const canvasPos = Chart.helpers.getRelativePosition(evt, chart);
            const dataY = chart.scales.y.getValueForPixel(canvasPos.y);
            
            if (!isSelecting) {
                // Start range selection
                rangeStart = dataY;
                isSelecting = true;
                console.log(`ğŸ¯ ë²”ìœ„ ì„ íƒ ì‹œì‘: ${dataY.toFixed(1)} ì„¸ë¯¸í†¤`);
                
                if ($pitchTestStatus) {
                    $pitchTestStatus.textContent = "ë“œë˜ê·¸í•´ì„œ ì—°ìŠµí•  ë²”ìœ„ë¥¼ ì„¤ì •í•˜ì„¸ìš”";
                    $pitchTestStatus.className = "text-center text-warning small fw-bold";
                }
            } else {
                // End range selection
                rangeEnd = dataY;
                isSelecting = false;
                
                // Ensure start is lower than end
                const minRange = Math.min(rangeStart, rangeEnd);
                const maxRange = Math.max(rangeStart, rangeEnd);
                
                createPitchRange(minRange, maxRange);
                
                // ğŸ¯ ë²”ìœ„ ì¤‘ê°„ê°’ì„ ëª©í‘œ ìŒë†’ì´ë¡œ ì„¤ì •
                pitchRange = {min: minRange, max: maxRange};
                targetPitch = (minRange + maxRange) / 2; // ë²”ìœ„ì˜ ì¤‘ê°„ê°’
                
                console.log(`ğŸ¯ ë²”ìœ„ ì„ íƒ ì™„ë£Œ: ${minRange.toFixed(1)} ~ ${maxRange.toFixed(1)} ì„¸ë¯¸í†¤`);
                console.log(`ğŸ¯ ëª©í‘œ ìŒë†’ì´ ì„¤ì •: ${targetPitch.toFixed(1)} ì„¸ë¯¸í†¤ (ë²”ìœ„ ì¤‘ì‹¬)`);
                
                // ğŸ¯ ìŒë†’ì´ í…ŒìŠ¤íŠ¸ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                updatePitchTestButtons();
                
                if ($pitchTestStatus) {
                    $pitchTestStatus.textContent = `ì—°ìŠµ ë²”ìœ„: ${minRange.toFixed(1)}~${maxRange.toFixed(1)} ì„¸ë¯¸í†¤ | ìŒë†’ì´ í…ŒìŠ¤íŠ¸ ì‹œì‘ ê°€ëŠ¥!`;
                    $pitchTestStatus.className = "text-center text-success small fw-bold";
                }
                
                rangeStart = null;
                rangeEnd = null;
            }
        }
    }
});

// Update chart range based on inputs or data
function updateChartRange(minVal = null, maxVal = null) {
    const currentMin = minVal !== null ? minVal : parseFloat($semitoneMin?.value || -6);
    const currentMax = maxVal !== null ? maxVal : parseFloat($semitoneMax?.value || 12);
    
    if (chart) {
        chart.options.scales.y.min = currentMin;
        chart.options.scales.y.max = currentMax;
        
        // ë²”ìœ„ê°€ ë°”ë€Œë©´ ìŒì ˆ ë¼ë²¨ ìœ„ì¹˜ë„ ë‹¤ì‹œ ê³„ì‚°
        if (refSyll && refSyll.length > 0) {
            addSyllableAnnotations(refSyll);
        }
        
        const unitName = currentYAxisUnit === 'qtone' ? 'Q-tone' : 'semitone';
        const unitSymbol = currentYAxisUnit === 'qtone' ? 'qt' : 'st';
        
        if ($status) {
            $status.textContent = `í‘œì‹œ ë²”ìœ„ê°€ ${currentMin}~${currentMax} ${unitSymbol}ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤`;
            setTimeout(() => $status.textContent = '', 2000);
        }
        
        chart.update();
        console.log(`ğŸ¯ Chart range updated: ${currentMin} to ${currentMax} ${unitName}`);
    }
    
    // Update input values
    if ($semitoneMin) $semitoneMin.value = currentMin;
    if ($semitoneMax) $semitoneMax.value = currentMax;
    
}

// ğŸ¯ ì„¸ë¯¸í†¤ê³¼ Qtë¥¼ Hzë¡œ ë³€í™˜í•´ì„œ ë²”ìœ„ í‘œì‹œ
function updateFrequencyRangeDisplay(minSemitone, maxSemitone) {
    if (!$freqRangeDisplay) return;
    
    const refFreq = refMedian || 200; // ê¸°ì¤€ ì£¼íŒŒìˆ˜ (Hz)
    const minHz = (refFreq * Math.pow(2, minSemitone / 12)).toFixed(1);
    const maxHz = (refFreq * Math.pow(2, maxSemitone / 12)).toFixed(1);
    
    // ğŸ¯ Qt ë‹¨ìœ„ë¡œë„ ê³„ì‚° (110 Hz ê¸°ì¤€)
    const minQt = f0ToQt(minHz);
    const maxQt = f0ToQt(maxHz);
    
    $freqRangeDisplay.innerHTML = `
        <div>Hz: ${minHz}~${maxHz} (ê¸°ì¤€: ${refFreq.toFixed(1)}Hz)</div>
        <div class="small text-muted">Qt: ${minQt.toFixed(1)}~${maxQt.toFixed(1)} (ìŒì„±í•™ ê¸°ì¤€: 110Hz)</div>
    `;
    
    console.log(`ğŸ¯ Frequency range: ${minHz}-${maxHz} Hz (ê¸°ì¤€: ${refFreq}Hz)`);
    console.log(`ğŸ¯ Qt range: ${minQt.toFixed(1)}-${maxQt.toFixed(1)} Qt (ê¸°ì¤€: 110Hz)`);
}

// ğŸ¯ ì‹¤ì‹œê°„ Hz í‘œì‹œ ì—…ë°ì´íŠ¸ (ìŒë†’ì´ í…ŒìŠ¤íŠ¸ ì „ìš©)
function updateLiveHzDisplay(currentHz) {
    if (!chart || !chart.data.datasets[3] || !pitchTestActive) return;
    
    const liveHzDataset = chart.data.datasets[3];
    if (!liveHzDataset.data) liveHzDataset.data = [];
    
    // ğŸ¯ í˜„ì¬ ì‹œì ì—ì„œ Hz ê°’ì„ y1 ì¶•ì— í‘œì‹œ (ì‹œê°„ì€ í˜„ì¬ ì°¨íŠ¸ ë²”ìœ„ ì¤‘ì•™)
    const currentTime = Date.now() / 1000;
    const chartTimeRange = 5; // 5ì´ˆ ë²”ìœ„
    const relativeTime = (currentTime % chartTimeRange);
    
    // ê¸°ì¡´ ë°ì´í„° í´ë¦¬ì–´ (ì‹¤ì‹œê°„ ë‹¨ì¼ í¬ì¸íŠ¸ë§Œ í‘œì‹œ)
    liveHzDataset.data = [{
        x: relativeTime,
        y: Math.max(80, Math.min(400, parseFloat(currentHz.toFixed(1)))) // y1 ì¶• ë²”ìœ„ì— ë§ê²Œ ì œí•œ, ì†Œìˆ˜ì  1ìë¦¬
    }];
    
    chart.update('none'); // ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ì—…ë°ì´íŠ¸
}

// ğŸ¯ ìŒë†’ì´ ë²”ìœ„ ìƒì„± (ë…¸ë€ìƒ‰ ë°°ê²½)
function createPitchRange(minSemitone, maxSemitone) {
    if (!chart) return;
    
    // ê¸°ì¡´ ë²”ìœ„ ì œê±°
    clearPitchRange();
    
    // Chart.js annotationìœ¼ë¡œ ë…¸ë€ìƒ‰ ë°°ê²½ ì˜ì—­ ì¶”ê°€
    const rangeAnnotation = {
        type: 'box',
        yMin: minSemitone,
        yMax: maxSemitone,
        backgroundColor: 'rgba(255, 255, 0, 0.2)', // ë…¸ë€ìƒ‰ ë°˜íˆ¬ëª…
        borderColor: 'rgba(255, 255, 0, 0.8)',
        borderWidth: 2,
        label: {
            enabled: true,
            content: `ì—°ìŠµ ë²”ìœ„: ${minSemitone.toFixed(1)}~${maxSemitone.toFixed(1)}`,
            position: 'start',
            backgroundColor: 'rgba(255, 255, 0, 0.8)',
            color: 'black',
            font: {
                size: 12,
                weight: 'bold'
            }
        }
    };
    
    // ìƒë‹¨ ë° í•˜ë‹¨ ì°¸ì¡°ì„  ì¶”ê°€
    const topLine = {
        type: 'line',
        yMin: maxSemitone,
        yMax: maxSemitone,
        borderColor: 'rgba(255, 165, 0, 1)',
        borderWidth: 1,
        borderDash: [5, 5]
    };
    
    const bottomLine = {
        type: 'line',
        yMin: minSemitone,
        yMax: minSemitone,
        borderColor: 'rgba(255, 165, 0, 1)',
        borderWidth: 1,
        borderDash: [5, 5]
    };
    
    // annotation í”ŒëŸ¬ê·¸ì¸ì— ì¶”ê°€
    if (!chart.options.plugins.annotation) {
        chart.options.plugins.annotation = { annotations: {} };
    }
    
    chart.options.plugins.annotation.annotations['pitchRange'] = rangeAnnotation;
    chart.options.plugins.annotation.annotations['topLine'] = topLine;
    chart.options.plugins.annotation.annotations['bottomLine'] = bottomLine;
    
    chart.update();
    
    console.log(`ğŸ¯ ìŒë†’ì´ ì—°ìŠµ ë²”ìœ„ ìƒì„±: ${minSemitone.toFixed(1)}~${maxSemitone.toFixed(1)} ì„¸ë¯¸í†¤`);
}

// ğŸ¯ ë²”ìœ„ ë¯¸ë¦¬ë³´ê¸° (ë“œë˜ê·¸ ì¤‘)
function updateRangePreview(startY, currentY) {
    if (!chart) return;
    
    const minY = Math.min(startY, currentY);
    const maxY = Math.max(startY, currentY);
    
    // ë¯¸ë¦¬ë³´ê¸° annotation ì—…ë°ì´íŠ¸
    if (!chart.options.plugins.annotation) {
        chart.options.plugins.annotation = { annotations: {} };
    }
    
    chart.options.plugins.annotation.annotations['previewRange'] = {
        type: 'box',
        yMin: minY,
        yMax: maxY,
        backgroundColor: 'rgba(255, 255, 0, 0.1)',
        borderColor: 'rgba(255, 255, 0, 0.5)',
        borderWidth: 2,
        borderDash: [10, 5]
    };
    
    chart.update('none');
}

// ğŸ¯ ìŒë†’ì´ ë²”ìœ„ ì œê±°
function clearPitchRange() {
    if (!chart || !chart.options.plugins.annotation) return;
    
    delete chart.options.plugins.annotation.annotations['pitchRange'];
    delete chart.options.plugins.annotation.annotations['topLine'];
    delete chart.options.plugins.annotation.annotations['bottomLine'];
    delete chart.options.plugins.annotation.annotations['previewRange'];
    
    chart.update();
    
    console.log('ğŸ¯ ìŒë†’ì´ ì—°ìŠµ ë²”ìœ„ ì œê±°');
}

// Calculate optimal range based on semitone data
function calculateOptimalRange(semitoneValues) {
    if (!semitoneValues || semitoneValues.length === 0) return {min: -6, max: 12};
    
    const validValues = semitoneValues.filter(v => v !== null && !isNaN(v));
    if (validValues.length === 0) return {min: -6, max: 12};
    
    const minValue = Math.min(...validValues);
    const maxValue = Math.max(...validValues);
    
    // Add padding (ì•½ 20% ì—¬ìœ )
    const padding = Math.max(2, (maxValue - minValue) * 0.2);
    const suggestedMin = Math.floor(minValue - padding);
    const suggestedMax = Math.ceil(maxValue + padding);
    
    return {min: suggestedMin, max: suggestedMax};
}

// Function to add syllable annotations to the chart
function addSyllableAnnotations(syllables) {
    if (!syllables || syllables.length === 0) return;
    
    // ğŸ§¹ ê¸°ì¡´ annotation ì™„ì „ ì´ˆê¸°í™” (ì•ˆì „í•œ ë°©ì‹)
    if (chart && chart.options && chart.options.plugins && chart.options.plugins.annotation) {
        chart.options.plugins.annotation.annotations = {};
        console.log("ğŸ§¹ ìŒì ˆ í‘œì‹œ ì´ˆê¸°í™” ì™„ë£Œ");
    }
    
    console.log('Adding annotations for', syllables.length, 'syllables:', syllables);
    
    // Position labels at top of chart (inside chart area)
    const chartMax = chart.options.scales.y.max;
    const chartMin = chart.options.scales.y.min;
    const labelY = chartMax - (chartMax - chartMin) * 0.05; // 5% from top (ë” ìƒë‹¨)
    
    syllables.forEach((syl, index) => {
        // Add vertical line at syllable boundaries
        if (index === 0) {
            // First syllable start
            chart.options.plugins.annotation.annotations[`start_${index}`] = {
                type: 'line',
                xMin: syl.start,
                xMax: syl.start,
                borderColor: 'rgba(255, 99, 132, 0.7)',
                borderWidth: 2,
                borderDash: [8, 4]
            };
        }
        
        // Syllable end (also start of next syllable)
        chart.options.plugins.annotation.annotations[`end_${index}`] = {
            type: 'line',
            xMin: syl.end,
            xMax: syl.end,
            borderColor: 'rgba(255, 99, 132, 0.7)',
            borderWidth: 2,
            borderDash: [8, 4]
        };
        
        // Add syllable label at the center
        const midTime = (syl.start + syl.end) / 2;
        chart.options.plugins.annotation.annotations[`label_${index}`] = {
            type: 'label',
            xValue: midTime,
            yValue: labelY,  // ğŸ¯ Position at top of chart
            content: syl.label || `êµ¬ê°„${index+1}`,
            backgroundColor: 'rgba(138, 43, 226, 0.8)',  // ì•½ê°„ íˆ¬ëª…í•œ ë³´ë¼ìƒ‰ ë°°ê²½
            borderColor: 'rgba(138, 43, 226, 0.9)',
            borderWidth: 1,
            borderRadius: 4,
            font: {
                size: 12,
                family: 'Noto Sans KR, -apple-system, sans-serif',
                weight: 'bold'
            },
            color: 'white',  // í°ìƒ‰ í…ìŠ¤íŠ¸
            padding: {
                x: 6,
                y: 3
            }
        };
    });
    
    // Force chart update to show annotations
    chart.update();
    console.log("ğŸ¯ Syllable annotations added and chart updated!");
}

// Function to update syllable analysis table (horizontal layout)
function updateSyllableAnalysisTable(syllableAnalysis) {
    const table = document.getElementById('syllable-analysis-table');
    const card = document.getElementById('syllable-analysis-card');
    
    if (!table || !syllableAnalysis || syllableAnalysis.length === 0) {
        if (card) card.style.display = 'none';
        return;
    }
    
    // Clear existing content and rebuild table structure
    table.innerHTML = '';
    
    // Create header row with syllables
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    const firstHeaderCell = headerRow.insertCell();
    firstHeaderCell.textContent = 'ë¶„ì„ í•­ëª©';
    firstHeaderCell.className = 'table-orange-header fw-bold';
    
    // Add syllable headers
    syllableAnalysis.forEach(syl => {
        const headerCell = headerRow.insertCell();
        headerCell.textContent = syl.label;  // syllable â†’ label
        headerCell.className = 'table-orange-header fw-bold text-center';
    });
    
    // Create tbody for data rows
    const tbody = table.createTBody();
    
    // Helper function to add a data row
    function addDataRow(label, getValue) {
        const row = tbody.insertRow();
        const labelCell = row.insertCell();
        labelCell.textContent = label;
        labelCell.className = 'fw-bold';
        
        syllableAnalysis.forEach(syl => {
            const dataCell = row.insertCell();
            dataCell.innerHTML = getValue(syl);
            dataCell.className = 'text-center';
        });
    }
    
    // Add data rows - ì˜¬ë°”ë¥¸ í•„ë“œëª… ì‚¬ìš©
    addDataRow('ì§€ì†ì‹œê°„', (syl) => `${(syl.duration || 0).toFixed(0)}ms`);
    
    addDataRow('í‰ê·  í”¼ì¹˜', (syl) => {
        const meanHz = syl.f0 || 0;  // pitch_mean â†’ f0
        const meanSemitone = syl.semitone || 0;
        return `${meanHz.toFixed(1)}Hz<br><small>(${meanSemitone.toFixed(1)}st)</small>`;
    });
    
    addDataRow('Q-tone', (syl) => {
        const qtone = syl.qtone || 0;
        return `${qtone.toFixed(1)}`;
    });
    
    addDataRow('ê°•ë„', (syl) => `${(syl.intensity || 0).toFixed(1)}dB`);
    
    addDataRow('êµ¬ê°„', (syl) => {
        const start = syl.start || 0;
        const end = syl.end || 0;
        return `${start.toFixed(2)}s - ${end.toFixed(2)}s`;
    });
    
    // Show the card
    card.style.display = 'block';
    
    console.log(`Updated syllable analysis table with ${syllableAnalysis.length} columns`);
}

// Utility functions
function mean(arr) {
    return arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
}

function clamp(v, a, b) {
    return Math.min(b, Math.max(a, v));
}

// Convert Hz to semitone relative to reference median
function f0ToSemitone(f0, refMedian = 200) {
    if (f0 <= 0 || refMedian <= 0) return 0;
    return 12 * Math.log2(f0 / refMedian);
}

// ğŸ¯ ìŒì„±í•™ ì—°êµ¬ í‘œì¤€: Qt ë‹¨ìœ„ ê³„ì‚° (200Hz ê¸°ì¤€ìœ¼ë¡œ ì¡°ì •, 0~25 ë“±ê¸‰)
function f0ToQt(f0) {
    if (f0 <= 0) return 0;
    // 200Hz ê¸°ì¤€ Q-tone ì²´ê³„ (ì‹¤ì œ ìŒì„± ë²”ìœ„ì— ë§ê²Œ ì¡°ì •)
    const qt = 12 + 12 * Math.log2(f0 / 200); // 200Hz = 12qtë¡œ ì¤‘ì•™ ì„¤ì •
    return Math.max(0, Math.min(25, qt)); // 0~25 ë²”ìœ„ë¡œ ì œí•œ
}

// ğŸ¯ Qtë¥¼ Hzë¡œ ë³€í™˜ (0~25 ë“±ê¸‰ ë²”ìœ„ ì²´í¬)
function qtToF0(qt) {
    // 0~25 ë²”ìœ„ë¡œ ì œí•œ
    const limitedQt = Math.max(0, Math.min(25, qt));
    // 200Hz ê¸°ì¤€ìœ¼ë¡œ ì—­ê³„ì‚° (12qt = 200Hz)
    return 200 * Math.pow(2, (limitedQt - 12) / 12);
}


function normF0(f0, meanF0, maxF0) {
    if (f0 <= 0) return 0;
    // Simple linear scaling from 50Hz to 500Hz for better visibility
    const minF0 = 50;
    const maxF0Range = 500;
    return clamp((f0 - minF0) / (maxF0Range - minF0), 0, 1);
}

function normInt(db) {
    return clamp((db + 60) / 60, 0, 1);
}

// Reference analysis - moved to setupEventHandlers function

// ğŸ¯ ë°±ì—”ë“œ Praat ë¶„ì„ìœ¼ë¡œ ì˜¤ë””ì˜¤ í”„ë ˆì„ ì „ì†¡
async function sendFrameToBackend(frame, sampleRate) {
    try {
        // Float32Arrayë¥¼ WAV í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        const audioBlob = new Blob([frame.buffer], { type: 'audio/wav' });
        
        const formData = new FormData();
        formData.append('audio', audioBlob, 'frame.wav');
        
        const response = await fetch('http://localhost:8000/analyze_live_audio', {
            method: 'POST',
            body: formData
        });
        
        if (response.ok) {
            const result = await response.json();
            if (result.success && result.pitch_data.length > 0) {
                // ğŸ¯ Praat ë¶„ì„ ê²°ê³¼ë¡œ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
                result.pitch_data.forEach(point => {
                    const f0 = point.f0;
                    const semitone = point.semitone;
                    
                    // Yì¶• ë‹¨ìœ„ì— ë§ê²Œ ë³€í™˜
                    let yValue;
                    if (currentYAxisUnit === 'qtone') {
                        yValue = f0ToQt(f0);
                    } else {
                        yValue = semitone; // ì´ë¯¸ semitoneìœ¼ë¡œ ê³„ì‚°ë¨
                    }
                    
                    const tNow = Date.now() / 1000 - startTime;
                    
                    liveBuffer.push({
                        t: tNow,
                        f0: f0,
                        semitone: yValue,
                        int: 0.5 // ê¸°ë³¸ intensity
                    });
                    
                    // ì‹¤ì‹œê°„ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
                    if (tNow > tLive + 0.05) {
                        addLiveDataToChart(yValue, 0.5);
                        tLive = tNow;
                        
                        const unitLabel = currentYAxisUnit === 'qtone' ? 'qt' : 'st';
                        console.log(`ğŸ¯ Praat: ${f0.toFixed(0)}Hzâ†’${yValue.toFixed(1)}${unitLabel}`);
                    }
                });
            }
        }
    } catch (error) {
        console.error('ğŸ”¥ ë°±ì—”ë“œ Praat ë¶„ì„ ì˜¤ë¥˜:', error);
        // ì˜¤ë¥˜ ì‹œ ê¸°ì¡´ YIN ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ fallback
        const f0 = yinPitch(frame, sampleRate);
        if (f0 > 0 && f0 < 1000) {
            console.log('ğŸ”„ YIN fallback ì‚¬ìš©');
            // ê¸°ì¡´ ì²˜ë¦¬ ë¡œì§...
        }
    }
}

// Enhanced YIN-based pitch estimation with better sensitivity (fallbackìš©)
function yinPitch(frame, sampleRate) {
    const N = frame.length;
    const tauMax = Math.floor(sampleRate / 50);   // Lower floor for better low pitch detection
    const tauMin = Math.floor(sampleRate / 800);  // Higher ceiling for better accuracy
    const diff = new Float32Array(tauMax + 1);
    
    // Pre-emphasize signal to improve pitch detection
    const emphasized = new Float32Array(N);
    emphasized[0] = frame[0];
    for (let i = 1; i < N; i++) {
        emphasized[i] = frame[i] - 0.95 * frame[i-1];
    }
    
    // Calculate difference function with emphasized signal
    for (let tau = 1; tau <= tauMax; tau++) {
        let s = 0;
        for (let i = 0; i < N - tau; i++) {
            const d = emphasized[i] - emphasized[i + tau];
            s += d * d;
        }
        diff[tau] = s;
    }
    
    // Calculate cumulative normalized difference with improved formula
    const cmnd = new Float32Array(tauMax + 1);
    let run = 0;
    for (let tau = 1; tau <= tauMax; tau++) {
        run += diff[tau];
        if (run > 0) {
            cmnd[tau] = diff[tau] / (run / tau);
        } else {
            cmnd[tau] = 1;
        }
    }
    
    // Find minimum with more lenient threshold
    let best = -1, minv = 1e9;
    for (let t = tauMin; t <= tauMax; t++) {
        if (cmnd[t] < minv) {
            minv = cmnd[t];
            best = t;
        }
    }
    
    // More lenient threshold for better detection (like Praat's voicing_threshold=0.45)
    return (best > 0 && minv < 0.3) ? sampleRate / best : 0;
}

function frameEnergy(frame) {
    let s = 0;
    for (let i = 0; i < frame.length; i++) {
        s += frame[i] * frame[i];
    }
    const rms = Math.sqrt(s / frame.length);
    // Use same reference as Praat for dB calculation
    return 20 * Math.log10(Math.max(rms, 1e-10));
}

function vadSyllableTracker(intDb, time) {
    // More sensitive thresholds for better voice activity detection
    const thrOn = -40, thrOff = -50;
    const last = sylCuts[sylCuts.length - 1];
    const voiced = intDb > thrOn;
    const unvoiced = intDb < thrOff;
    
    if (!last) {
        if (voiced) {
            sylCuts.push({start: time, end: null});
        }
    } else {
        if (last.end === null) {
            if (unvoiced && (time - last.start) > 0.07) {
                last.end = time;
            }
        } else {
            if (voiced) {
                sylCuts.push({start: time, end: null});
            }
        }
    }
}

// ğŸ¯ í˜„ì¬ ë°œí™” ì¤‘ì¸ ìŒì ˆ ì¸ë±ìŠ¤ ì¶”ì 
let currentSyllableIndex = 0;
let syllableStartTime = 0;

function syllableBasedTimeWarp(liveSeries) {
    if (!refSyll.length) return liveSeries;
    
    const completedSyllables = sylCuts.filter(s => s.end !== null);
    const currentSyllable = sylCuts.find(s => s.end === null);
    
    // ìŒì ˆ ì§„í–‰ ì—…ë°ì´íŠ¸
    if (completedSyllables.length > currentSyllableIndex) {
        currentSyllableIndex = Math.min(completedSyllables.length, refSyll.length - 1);
        console.log(`ğŸ¯ ìŒì ˆ ì§„í–‰: ${currentSyllableIndex + 1}/${refSyll.length} - "${refSyll[currentSyllableIndex]?.label || 'N/A'}"`);
    }
    
    // ğŸ¯ ë°ì´í„°ê°€ ë„ˆë¬´ ë§ìœ¼ë©´ ìµœê·¼ ê²ƒë§Œ ì‚¬ìš© (ì„±ëŠ¥ í–¥ìƒ)
    const recentData = liveSeries.length > 100 ? liveSeries.slice(-100) : liveSeries;
    
    return recentData.map((p, index) => {
        const t = p.x;
        
        // ğŸ¯ í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ìŒì ˆ ì¸ë±ìŠ¤ ê²°ì •
        let targetSylIndex = Math.min(currentSyllableIndex, refSyll.length - 1);
        
        // í˜„ì¬ ë°œí™” ì¤‘ì¸ ìŒì ˆì´ ìˆê³ , ìœ íš¨í•œ ì°¸ì¡° ìŒì ˆì´ ìˆëŠ” ê²½ìš°
        if (currentSyllable && targetSylIndex >= 0 && targetSylIndex < refSyll.length) {
            const refSyl = refSyll[targetSylIndex];
            const currentSylStart = currentSyllable.start || 0;
            
            // ğŸ¯ ìŒì„± ë°ì´í„°ê°€ í˜„ì¬ ìŒì ˆ ì‹œì‘ ì´í›„ì¸ì§€ í™•ì¸
            if (t >= currentSylStart) {
                const liveDuration = t - currentSylStart;
                const refDuration = Math.max(refSyl.end - refSyl.start, 0.1); // ìµœì†Œ 0.1ì´ˆ
                
                // ìŒì ˆ ë‚´ ìƒëŒ€ì  ìœ„ì¹˜ ê³„ì‚° (0~1, ìµœëŒ€ 1.5ê¹Œì§€ í—ˆìš©)
                const relativePos = Math.max(0, Math.min(1.5, liveDuration / refDuration));
                
                // ì°¸ì¡° ìŒì ˆ ë‚´ ì‹œê°„ìœ¼ë¡œ ë§¤í•‘
                const mappedTime = refSyl.start + (relativePos * refDuration);
                
                // ğŸ¯ ë””ë²„ê¹… ë¡œê·¸ (ê°€ë”ë§Œ)
                if (Math.random() < 0.01) {
                    console.log(`ğŸ¯ ì‹œê°„ ë§¤í•‘: live=${t.toFixed(2)}s â†’ mapped=${mappedTime.toFixed(2)}s (ìŒì ˆ${targetSylIndex+1}: ${refSyl.label})`);
                }
                
                return {x: mappedTime, y: p.y, int: p.int};
            }
        }
        
        // ğŸ¯ ì™„ë£Œëœ ìŒì ˆë“¤ì˜ ê²½ìš° - ì„ í˜• ë³´ê°„ìœ¼ë¡œ ë” ìì—°ìŠ¤ëŸ½ê²Œ
        if (completedSyllables.length > 0 && targetSylIndex >= 0 && targetSylIndex < refSyll.length) {
            const refSyl = refSyll[targetSylIndex];
            
            // í•´ë‹¹í•˜ëŠ” ì™„ë£Œëœ ìŒì ˆ ì°¾ê¸°
            const completedSyl = completedSyllables[Math.min(targetSylIndex, completedSyllables.length - 1)];
            if (completedSyl) {
                const liveStart = completedSyl.start || 0;
                const liveEnd = completedSyl.end || (liveStart + 0.3); // ê¸°ë³¸ 0.3ì´ˆ
                const liveDuration = Math.max(liveEnd - liveStart, 0.1);
                
                // ìŒì ˆ ë‚´ì—ì„œì˜ ìƒëŒ€ì  ìœ„ì¹˜
                const relativeInSyl = Math.max(0, Math.min(1, (t - liveStart) / liveDuration));
                const mappedTime = refSyl.start + (relativeInSyl * (refSyl.end - refSyl.start));
                
                return {x: mappedTime, y: p.y, int: p.int};
            }
        }
        
        // ğŸ¯ ê¸°ë³¸ ë§¤í•‘ - ë¹„ë¡€ì‹ìœ¼ë¡œ ì „ì²´ ì‹œê°„ì— ë§ì¶¤
        const maxRefTime = refSyll.length > 0 ? refSyll[refSyll.length - 1].end : 2.0;
        const maxLiveTime = Math.max(t, 0.5);
        const scaledTime = (t / maxLiveTime) * maxRefTime;
        
        return {x: scaledTime, y: p.y, int: p.int};
    });
}

// ğŸ¯ ===== PITCH TEST ê¸°ëŠ¥ =====

// ì°¸ì¡°ìŒì„± ë¶€ë¶„ ì—°ìŠµ ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬
function handleTwoPointPractice() {
    if (!refCurve || refCurve.length === 0) {
        alert('ì°¸ì¡°ìŒì„± ë¶„ì„ì„ ë¨¼ì € ì§„í–‰í•´ì£¼ì„¸ìš”.\n\n"ëª¨ë¸ ìŒì„± ë¶„ì„" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì°¸ì¡° ë°ì´í„°ë¥¼ ë¶„ì„í•œ í›„ ì´ìš©í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
        return;
    }
    
    if (!pitchRange) {
        alert('ì°¨íŠ¸ì—ì„œ ë“œë˜ê·¸í•˜ì—¬ ì—°ìŠµí•  ë‘ ìŒì˜ ë²”ìœ„ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.');
        return;
    }
    
    // ë‘ ìŒ ì—°ìŠµ ë¡œì§ ì‹¤í–‰ (ê¸°ì¡´ ìŒë†’ì´ í…ŒìŠ¤íŠ¸ì™€ ë™ì¼)
    startPitchTest();
}

function setupPitchTestHandlers() {
    if (!$btnPitchTest || !$btnStopPitchTest || !$btnTwoPointPractice) return;
    
    // ìŒë†’ì´ í…ŒìŠ¤íŠ¸ ì‹œì‘ (íŒì—… ì—†ì´ ë°”ë¡œ ì‹œì‘)
    $btnPitchTest.onclick = async () => {
        // ğŸ¯ íŒì—… ì—†ì´ ë°”ë¡œ ìŒë†’ì´ ì—°ìŠµ ì‹œì‘
        await startPitchTest();
    };
    
    // ìŒë†’ì´ í…ŒìŠ¤íŠ¸ ì¤‘ì§€
    $btnStopPitchTest.onclick = () => {
        stopPitchTest();
    };
    
    // ì°¸ì¡°ìŒì„± ë¶€ë¶„ ì—°ìŠµ
    $btnTwoPointPractice.onclick = () => {
        handleTwoPointPractice();
    };
}

async function startPitchTest() {
    if (pitchTestActive) return;
    
    try {
        pitchTestActive = true;
        pitchTestBuffer = [];
        chartFrozen = true; // ğŸ¯ ì°¨íŠ¸ ì™„ì „ ê³ ì •
        
        // ğŸ¬ ì—°ìŠµ ë°ì´í„° ì €ì¥ ì‹œì‘
        practiceRecordingData = [];
        isRecordingPractice = true;
        console.log("ğŸ¬ ì—°ìŠµ ì‹œê°í™” ì €ì¥ ì‹œì‘");
        
        // ğŸ¯ í˜„ì¬ ì°¨íŠ¸ ìŠ¤ì¼€ì¼ì„ ì €ì¥ (ì°¸ì¡°ìŒì„± ë²”ìœ„ ë³´ì¡´)
        if (chart && chart.scales) {
            originalScales = {
                xMin: chart.scales.x.min,
                xMax: chart.scales.x.max,
                yMin: chart.scales.y.min,
                yMax: chart.scales.y.max
            };
            console.log("ğŸ¯ ì›ë³¸ ì°¨íŠ¸ ìŠ¤ì¼€ì¼ ì €ì¥:", originalScales);
        }
        
        // ğŸ¯ ë§ˆì´í¬ ì ‘ê·¼ ì „ ê°€ì´ë“œ ë©”ì‹œì§€
        $pitchTestStatus.innerHTML = `
            <div class="text-center">
                <div class="spinner-border spinner-border-sm me-2"></div>
                <strong>ğŸ¤ ë§ˆì´í¬ë¥¼ ì¼œëŠ” ì¤‘...</strong>
            </div>
        `;
        $pitchTestStatus.className = "text-center text-info small fw-bold";
        
        console.log("ğŸ¯ ì°¨íŠ¸ ì™„ì „ ê³ ì • ëª¨ë“œ ì‹œì‘ - ì°¸ì¡°ìŒì„± ë²”ìœ„ ë³´ì¡´");
        
        $btnPitchTest.disabled = true;
        $btnStopPitchTest.disabled = false;
        
        // ğŸ¤ ë§ˆì´í¬ ì ‘ê·¼
        console.log("ğŸ¯ Pitch Test: ë§ˆì´í¬ ì ‘ê·¼ ì¤‘...");
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(device => device.kind === 'audioinput');
        
        let selectedDeviceId = null;
        const usbMic = audioInputs.find(device => 
            device.label.toLowerCase().includes('usb') || 
            device.label.toLowerCase().includes('external')
        );
        
        if (usbMic) {
            selectedDeviceId = usbMic.deviceId;
            console.log("ğŸ¯ Pitch Test: USB ë§ˆì´í¬ ì‚¬ìš©");
        }
        
        const constraints = {
            audio: {
                sampleRate: 16000,
                channelCount: 1,
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false
            }
        };
        
        if (selectedDeviceId) {
            constraints.audio.deviceId = { exact: selectedDeviceId };
        }
        
        pitchTestStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        // AudioContext ì„¤ì •
        pitchTestAudioCtx = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: 16000
        });
        
        if (pitchTestAudioCtx.state === 'suspended') {
            await pitchTestAudioCtx.resume();
        }
        
        const src = pitchTestAudioCtx.createMediaStreamSource(pitchTestStream);
        pitchTestProcNode = pitchTestAudioCtx.createScriptProcessor(2048, 1, 1);
        
        const ring = new Float32Array(1600); // 100ms buffer
        let ringPos = 0;
        let accTime = 0;
        
        src.connect(pitchTestProcNode);
        pitchTestProcNode.connect(pitchTestAudioCtx.destination);
        
        // ì‹¤ì‹œê°„ í”¼ì¹˜ ë¶„ì„
        pitchTestProcNode.onaudioprocess = (e) => {
            if (!pitchTestActive) return;
            
            const ch = e.inputBuffer.getChannelData(0);
            
            // Fill ring buffer
            for (let i = 0; i < ch.length; i++) {
                ring[ringPos % ring.length] = ch[i];
                ringPos++;
            }
            
            accTime += ch.length / pitchTestAudioCtx.sampleRate;
            
            // ğŸš€ ì‹¤ì‹œê°„ ì²˜ë¦¬: 25ms ê°„ê²©ìœ¼ë¡œ ë” ë¹ ë¥¸ ì—…ë°ì´íŠ¸ (ì§€ì—° ìµœì†Œí™”)
            if (accTime >= 0.025) {
                accTime = 0;
                
                const frame = new Float32Array(800); // 50ms frame
                const start = (ringPos - 800 + ring.length) % ring.length;
                
                for (let j = 0; j < 800; j++) {
                    frame[j] = ring[(start + j) % ring.length];
                }
                
                const f0 = yinPitch(frame, pitchTestAudioCtx.sampleRate);
                const dB = frameEnergy(frame);
                
                if (f0 > 0 && f0 < 1000) {
                    // ğŸ¯ í˜„ì¬ Yì¶• ë‹¨ìœ„ì— ë§ê²Œ ë³€í™˜
                    let yValue;
                    if (currentYAxisUnit === 'qtone') {
                        yValue = f0ToQt(f0);
                    } else {
                        yValue = f0ToSemitone(f0, refMedian);
                    }
                    
                    // ğŸš€ ì‹¤ì‹œê°„ í”¼ë“œë°±: ëª¨ë“  ë³€í™”ë¥¼ ì¦‰ì‹œ ë°˜ì˜ (í•„í„°ë§ ìµœì†Œí™”)
                    const threshold = PERCEPTUAL_THRESHOLDS[currentYAxisUnit];
                    const isPerceptibleChange = lastPerceptiblePitch === null || 
                        Math.abs(yValue - lastPerceptiblePitch) >= threshold;
                    
                    // ì‹¤ì‹œê°„ì„±ì„ ìœ„í•´ ëª¨ë“  ìœ íš¨í•œ í”¼ì¹˜ ì¦‰ì‹œ ì²˜ë¦¬
                    if (isPerceptibleChange || true) { // í•­ìƒ ì—…ë°ì´íŠ¸
                        lastPerceptiblePitch = yValue;
                        currentLiveHz = f0; // ì‹¤ì‹œê°„ Hz ì—…ë°ì´íŠ¸
                        
                        // ğŸ”´ ìŒë†’ì´ í…ŒìŠ¤íŠ¸: ì§€ê° ê°€ëŠ¥í•œ ë³€í™”ë§Œ í‘œì‹œ
                        updatePitchTestChart(yValue);
                        
                        // ğŸ¬ ì—°ìŠµ ë°ì´í„° ì €ì¥
                        if (isRecordingPractice) {
                            const practicePoint = {
                                timestamp: Date.now(),
                                time: tLive,
                                pitch: yValue,
                                frequency: f0,
                                unit: currentYAxisUnit
                            };
                            practiceRecordingData.push(practicePoint);
                        }
                        
                        // ğŸ¯ ì‹¤ì‹œê°„ Hz ê°’ì„ ìš°ì¸¡ ì¶•ì— í‘œì‹œ
                        updateLiveHzDisplay(f0);
                    } else {
                        // ì§€ê°í•˜ê¸° ì–´ë ¤ìš´ ë¯¸ì„¸í•œ ë³€í™”ëŠ” ë¬´ì‹œ
                        return;
                    }
                    
                    // ë²”ìœ„/ëª©í‘œ ì²´í¬
                    let feedback = "";
                    if (pitchRange) {
                        // ğŸ¯ ë²”ìœ„ë¥¼ í˜„ì¬ ë‹¨ìœ„ë¡œ ë³€í™˜
                        let convertedMin, convertedMax;
                        if (currentYAxisUnit === 'qtone') {
                            convertedMin = f0ToQt((refMedian || 200) * Math.pow(2, pitchRange.min / 12));
                            convertedMax = f0ToQt((refMedian || 200) * Math.pow(2, pitchRange.max / 12));
                        } else {
                            convertedMin = pitchRange.min;
                            convertedMax = pitchRange.max;
                        }
                        
                        const isInRange = yValue >= convertedMin && yValue <= convertedMax;
                        feedback = isInRange ? "ğŸŸ¢ ë²”ìœ„ ë‚´!" : "ğŸ”´ ë²”ìœ„ ë°–";
                        
                        let unitLabel = currentYAxisUnit === 'qtone' ? 'qt' : 'st';
                        
                        // ğŸš€ ë¡œê·¸ ìµœì†Œí™” (ì„±ëŠ¥ ìµœìš°ì„ )
                        if (Math.random() < 0.005) { // 0.5%ë§Œ ë¡œê·¸
                            console.log(`ğŸ¯ ${yValue.toFixed(0)}${unitLabel} (${convertedMin.toFixed(0)}~${convertedMax.toFixed(0)}) â†’ ${feedback}`);
                        }
                    } else if (targetPitch !== null) {
                        // ğŸ¯ ëª©í‘œê°’ì„ í˜„ì¬ ë‹¨ìœ„ë¡œ ë³€í™˜
                        let convertedTarget;
                        if (currentYAxisUnit === 'qtone') {
                            convertedTarget = f0ToQt((refMedian || 200) * Math.pow(2, targetPitch / 12));
                        } else {
                            convertedTarget = targetPitch;
                        }
                        
                        const diff = Math.abs(yValue - convertedTarget);
                        const threshold = currentYAxisUnit === 'qtone' ? 1.0 : 0.5;
                        const isAccurate = diff <= threshold;
                        feedback = isAccurate ? "ğŸŸ¢ ì •í™•!" : "ğŸŸ¡ ì¡°ì • í•„ìš”";
                        
                        let unitLabel = currentYAxisUnit === 'qtone' ? 'qt' : 'st';
                        
                        // ğŸš€ ë¡œê·¸ ìµœì†Œí™” (ì„±ëŠ¥ ìµœìš°ì„ )
                        if (Math.random() < 0.005) { // 0.5%ë§Œ ë¡œê·¸
                            console.log(`ğŸ¯ ${yValue.toFixed(0)}${unitLabel} vs ${convertedTarget.toFixed(0)}${unitLabel} â†’ ${feedback}`);
                        }
                    }
                }
            }
        };
        
        // ğŸ¯ ë§ˆì´í¬ ì—°ê²° ì„±ê³µ í›„ ì‚¬ìš©ì ê°€ì´ë“œ
        $pitchTestStatus.innerHTML = `
            <div class="text-center">
                <strong>ğŸ¤ ë§ˆì´í¬ ì—°ê²°ë¨!</strong><br>
                <span class="text-success">ğŸ“¢ "ì•„~" ì†Œë¦¬ë¥¼ ë‚´ë³´ì„¸ìš”. ë¹¨ê°„ì¤„ë¡œ í˜„ì¬ ìŒë†’ì´ê°€ í‘œì‹œë©ë‹ˆë‹¤.</span><br>
                <small class="text-muted">ë°œì„± í›„ ì°¨íŠ¸ì—ì„œ ë“œë˜ê·¸í•˜ì—¬ ì—°ìŠµ ë²”ìœ„ë¥¼ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</small>
            </div>
        `;
        $pitchTestStatus.className = "text-center small fw-bold";
        
        console.log("ğŸ¯ Pitch Test ì‹œì‘ë¨");
        
    } catch (error) {
        console.error("ğŸ¯ Pitch Test ì˜¤ë¥˜:", error);
        $pitchTestStatus.textContent = "ë§ˆì´í¬ ì ‘ê·¼ ì˜¤ë¥˜: " + error.message;
        $pitchTestStatus.className = "text-center text-danger small";
        stopPitchTest();
    }
}

function stopPitchTest() {
    if (!pitchTestActive) return;
    
    pitchTestActive = false;
    chartFrozen = false; // ğŸ¯ ì°¨íŠ¸ ê³ ì • í•´ì œ
    originalScales = null; // ğŸ¯ ì €ì¥ëœ ìŠ¤ì¼€ì¼ ì œê±°
    
    // ğŸ¯ ìŒì„± ì§€ì†ì‹œê°„ ê¸°ë¡ ì´ˆê¸°í™”
    currentPitchHistory = [];
    lastPitchValue = null;
    pitchStartTime = null;
    
    // ğŸ¬ ì—°ìŠµ ë°ì´í„° ì €ì¥ ì¢…ë£Œ
    isRecordingPractice = false;
    if (practiceRecordingData.length > 0) {
        console.log(`ğŸ¬ ì—°ìŠµ ì‹œê°í™” ì €ì¥ ì™„ë£Œ: ${practiceRecordingData.length}ê°œ ë°ì´í„° í¬ì¸íŠ¸`);
        updateButtons(); // ì¬ìƒ ë²„íŠ¼ í™œì„±í™”
    }
    
    if (pitchTestStream) {
        pitchTestStream.getTracks().forEach(track => track.stop());
        pitchTestStream = null;
    }
    
    if (pitchTestProcNode) {
        pitchTestProcNode.disconnect();
        pitchTestProcNode = null;
    }
    
    if (pitchTestAudioCtx) {
        pitchTestAudioCtx.close();
        pitchTestAudioCtx = null;
    }
    
    $btnPitchTest.disabled = false;
    $btnStopPitchTest.disabled = true;
    
    // ğŸ¯ ìŒë†’ì´ ì—°ìŠµ ì¢…ë£Œ ë©”ì‹œì§€ ê°œì„ 
    $pitchTestStatus.innerHTML = `
        <div class="text-center">
            <strong>ğŸ¤ ìŒë†’ì´ ì—°ìŠµì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.</strong><br>
            <small class="text-muted">ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ "ìŒë†’ì´ ì—°ìŠµ" ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.</small>
        </div>
    `;
    $pitchTestStatus.className = "text-center text-success small";
    
    // ğŸ”´ ë¹¨ê°„ í¬ì¸íŠ¸ ì œê±° (ìŒë†’ì´ í…ŒìŠ¤íŠ¸ ì „ìš©)
    if (chart && chart.data.datasets[4]) {
        chart.data.datasets[4].data = [];
    }
    
    // ğŸ¯ í˜„ì¬ ìŒë†’ì´ ê°€ë¡œì„  ì œê±°
    if (chart && chart.options.plugins.annotation && chart.options.plugins.annotation.annotations.currentPitchLine) {
        delete chart.options.plugins.annotation.annotations.currentPitchLine;
    }
    
    // ì‹¤ì‹œê°„ Hz í‘œì‹œ ì œê±°
    if (chart && chart.data.datasets[3]) {
        chart.data.datasets[3].data = [];
    }
    
    chart.update('none');
    
    console.log("ğŸ¯ Pitch Test ì¢…ë£Œ - ì°¨íŠ¸ ê³ ì • í•´ì œ");
}

// ğŸ¯ ìŒì„± ì§€ì†ì‹œê°„ ê¸°ë¡ì„ ìœ„í•œ ë³€ìˆ˜ë“¤
let currentPitchHistory = [];
let lastPitchValue = null;
let pitchStartTime = null;

// ğŸ¯ ìŒë†’ì´ í…ŒìŠ¤íŠ¸: ì™„ì „ ê³ ì • ì°¨íŠ¸ì—ì„œ ì§€ì†ì‹œê°„ì„ ì„  êµµê¸°ë¡œ í‘œí˜„
function updatePitchTestChart(currentValue) {
    if (!chart || !pitchTestActive || chartFrozen === false) return;
    
    // ğŸ¯ ì°¨íŠ¸ ìŠ¤ì¼€ì¼ì„ ì›ë³¸ìœ¼ë¡œ ì™„ì „ ê³ ì • (ì ˆëŒ€ ë³€ê²½ë˜ì§€ ì•Šë„ë¡)
    if (originalScales) {
        chart.scales.x.min = originalScales.xMin;
        chart.scales.x.max = originalScales.xMax;
        chart.scales.y.min = originalScales.yMin;
        chart.scales.y.max = originalScales.yMax;
        
        // ìŠ¤ì¼€ì¼ ì˜µì…˜ë„ ê³ ì •
        chart.options.scales.x.min = originalScales.xMin;
        chart.options.scales.x.max = originalScales.xMax;
        chart.options.scales.y.min = originalScales.yMin;
        chart.options.scales.y.max = originalScales.yMax;
    }
    
    // ğŸ”´ ë¹¨ê°„ í¬ì¸íŠ¸ ë°ì´í„°ì…‹ (5ë²ˆì§¸ ë°ì´í„°ì…‹, index 4)
    const redPointDataset = chart.data.datasets[4];
    if (!redPointDataset) return;
    
    // ğŸ¯ ì°¨íŠ¸ ì¤‘ì•™ ê³ ì • ìœ„ì¹˜ (ì ˆëŒ€ ë³€í•˜ì§€ ì•ŠìŒ)
    const refMidTime = originalScales ? (originalScales.xMin + originalScales.xMax) / 2 : 1.0;
    
    // ğŸ¯ ì§€ì†ì‹œê°„ ê³„ì‚°ì„ ìœ„í•œ ë‹¨ìœ„ë³„ í—ˆìš© ì˜¤ì°¨
    const currentTime = Date.now();
    const pitchTolerance = currentYAxisUnit === 'cent' ? 30 : (currentYAxisUnit === 'qtone' ? 0.5 : 0.3);
    
    if (lastPitchValue === null || Math.abs(currentValue - lastPitchValue) > pitchTolerance) {
        // ìƒˆë¡œìš´ ìŒë†’ì´ ì‹œì‘
        lastPitchValue = currentValue;
        pitchStartTime = currentTime;
    }
    
    // í˜„ì¬ ìŒë†’ì´ ì§€ì†ì‹œê°„ ê³„ì‚° (ì´ˆ ë‹¨ìœ„)
    const sustainDuration = pitchStartTime ? (currentTime - pitchStartTime) / 1000 : 0;
    
    // ğŸ¯ ì§€ì†ì‹œê°„ì— ë”°ë¥¸ ì‹œê°ì  ê°•ë„ ê³„ì‚° (0.1ì´ˆ ~ 2ì´ˆ ë²”ìœ„)
    const minDuration = 0.1;
    const maxDuration = 2.0;
    const normalizedDuration = Math.min(sustainDuration, maxDuration) / maxDuration;
    
    // ì„  êµµê¸°: ì§€ì†ì‹œê°„ì— ë”°ë¼ 2~8px (ë” ì„¸ë ¨ë˜ê²Œ)
    const lineWidth = 2 + (normalizedDuration * 6);
    
    // íˆ¬ëª…ë„: ì§€ì†ì‹œê°„ì— ë”°ë¼ 0.7~1.0 (ë” ì„ ëª…í•˜ê²Œ)
    const alpha = 0.7 + (normalizedDuration * 0.3);
    
    // ğŸ”´ ë¹¨ê°„ í¬ì¸íŠ¸ë§Œ ì—…ë°ì´íŠ¸
    redPointDataset.data = [{
        x: refMidTime,
        y: currentValue
    }];
    
    // ğŸ¯ í˜„ì¬ ë‹¨ìœ„ì— ë§ëŠ” í‘œì‹œ
    let unitLabel = currentYAxisUnit === 'qtone' ? 'qt' : 'st';
    
    // ğŸ¯ í˜„ì¬ ìŒë†’ì´ ê°€ë¡œì„  (ì§€ì†ì‹œê°„ìœ¼ë¡œ êµµê¸° í‘œí˜„)
    if (!chart.options.plugins.annotation) {
        chart.options.plugins.annotation = { annotations: {} };
    }
    
    chart.options.plugins.annotation.annotations.currentPitchLine = {
        type: 'line',
        yMin: currentValue,
        yMax: currentValue,
        borderColor: `rgba(255, 0, 0, ${alpha})`,
        borderWidth: lineWidth,
        borderDash: sustainDuration > 0.2 ? [] : [4, 2], // 0.2ì´ˆ ì´ìƒ ì§€ì†ì‹œ ì‹¤ì„ 
        label: {
            content: sustainDuration > 0.1 ? 
                `${currentValue.toFixed(1)}${unitLabel} (${sustainDuration.toFixed(1)}s)` : 
                `${currentValue.toFixed(1)}${unitLabel}`,
            enabled: true,
            position: 'end',
            backgroundColor: `rgba(255, 0, 0, ${Math.min(alpha + 0.2, 1.0)})`,
            color: 'white',
            font: { size: 11, weight: 'bold' },
            padding: 4
        }
    };
    
    // ğŸ¯ ì°¨íŠ¸ ì—…ë°ì´íŠ¸ (ìŠ¤ì¼€ì¼ì€ ì ˆëŒ€ ë³€ê²½ ì•ˆë¨)
    chart.update('none');
    
    // ğŸš€ ë¡œê·¸ ìµœì†Œí™” (ì‹¤ì‹œê°„ ì„±ëŠ¥ ìµœìš°ì„ )
    if (sustainDuration > 0.2 && Math.random() < 0.01) { // ë¡œê·¸ ëŒ€í­ ê°ì†Œ
        console.log(`ğŸ”´ ${currentValue.toFixed(0)}${unitLabel} ${sustainDuration.toFixed(1)}s`);
    }
}

function updatePitchTestStatus(currentValue, diff) {
    const accuracy = Math.max(0, 100 - (diff * 20)); // ì°¨ì´ì— ë”°ë¥¸ ì •í™•ë„
    
    // ë‹¨ìœ„ë³„ í‘œì‹œ
    let unitLabel = currentYAxisUnit === 'qtone' ? 'qt' : 'st';
    
    let message = `í˜„ì¬: ${currentValue.toFixed(1)}${unitLabel} | ëª©í‘œ: ${targetPitch.toFixed(1)}${unitLabel}`;
    let className = "text-center small fw-bold";
    
    if (diff < 0.5) {
        message += " | âœ… ì™„ë²½í•©ë‹ˆë‹¤!";
        className += " text-success";
    } else if (diff < 1.0) {
        message += " | ğŸ¯ ê±°ì˜ ë§ìŠµë‹ˆë‹¤!";
        className += " text-primary";
    } else if (diff < 2.0) {
        message += " | ğŸ“ˆ ì¡°ê¸ˆ ë” " + (currentValue < targetPitch ? "ë†’ê²Œ" : "ë‚®ê²Œ");
        className += " text-warning";
    } else {
        message += " | ğŸ”„ " + (currentValue < targetPitch ? "ë” ë†’ê²Œ" : "ë” ë‚®ê²Œ") + " ë°œì„±í•˜ì„¸ìš”";
        className += " text-danger";
    }
    
    $pitchTestStatus.textContent = message;
    $pitchTestStatus.className = className;
}

// ğŸ¯ ì°¨íŠ¸ í´ë¦­ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
function handleChartClick(event, chartInstance) {
    if (!chartInstance || pitchTestActive) return;
    
    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
    const dataX = chartInstance.scales.x.getValueForPixel(canvasPosition.x);
    const dataY = chartInstance.scales.y.getValueForPixel(canvasPosition.y);
    
    // ìœ íš¨í•œ ì„¸ë¯¸í†¤ ë²”ìœ„ì¸ì§€ í™•ì¸
    if (dataY >= -10 && dataY <= 15) {
        targetPitch = dataY;
        
        // ì°¸ì¡°ì„  ì¶”ê°€/ì—…ë°ì´íŠ¸
        addPitchReferenceLine(dataY);
        
        // UI ì—…ë°ì´íŠ¸
        $pitchTestStatus.textContent = `ëª©í‘œ ìŒë†’ì´: ${dataY.toFixed(1)} ì„¸ë¯¸í†¤ ì„ íƒë¨. "ìŒë†’ì´ í…ŒìŠ¤íŠ¸" ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”`;
        $pitchTestStatus.className = "text-center text-info small fw-bold";
        
        if ($btnPitchTest) {
            $btnPitchTest.disabled = false;
            $btnPitchTest.classList.remove('btn-outline-success');
            $btnPitchTest.classList.add('btn-success');
        }
        
        console.log(`ğŸ¯ ëª©í‘œ ìŒë†’ì´ ì„¤ì •: ${dataY.toFixed(1)} ì„¸ë¯¸í†¤`);
    }
}

// ğŸ¯ í”¼ì¹˜ ì°¸ì¡°ì„  ì¶”ê°€
function addPitchReferenceLine(semitoneValue) {
    if (!chart || !chart.options.plugins.annotation) return;
    
    // ê¸°ì¡´ ì°¸ì¡°ì„  ì œê±°
    if (chart.options.plugins.annotation.annotations.pitchTarget) {
        delete chart.options.plugins.annotation.annotations.pitchTarget;
    }
    
    // ìƒˆ ì°¸ì¡°ì„  ì¶”ê°€
    chart.options.plugins.annotation.annotations.pitchTarget = {
        type: 'line',
        yMin: semitoneValue,
        yMax: semitoneValue,
        borderColor: '#e74c3c',
        borderWidth: 1,
        borderDash: [10, 5],
        label: {
            enabled: true,
            content: `ëª©í‘œ: ${semitoneValue.toFixed(1)}st`,
            position: 'start',
            backgroundColor: '#e74c3c',
            color: 'white',
            font: {
                size: 12,
                weight: 'bold'
            }
        }
    };
    
    chart.update('none');
    console.log(`ğŸ¯ ì°¸ì¡°ì„  ì¶”ê°€: ${semitoneValue.toFixed(1)} ì„¸ë¯¸í†¤`);
}

// ğŸ¯ í”¼ì¹˜ í…ŒìŠ¤íŠ¸ ì°¸ì¡°ì„  ì œê±°
function removePitchReferenceLine() {
    if (chart && chart.options.plugins.annotation && chart.options.plugins.annotation.annotations.pitchTarget) {
        delete chart.options.plugins.annotation.annotations.pitchTarget;
        chart.update('none');
        console.log("ğŸ¯ ì°¸ì¡°ì„  ì œê±°ë¨");
    }
}

// ğŸ¯ updateButtons í•¨ìˆ˜ í™•ì¥ - í”¼ì¹˜ í…ŒìŠ¤íŠ¸ ë²„íŠ¼ ìƒíƒœë„ ê´€ë¦¬
function updatePitchTestButtons() {
    if (!$btnPitchTest || !$btnStopPitchTest) return;
    
    if (pitchTestActive) {
        $btnPitchTest.disabled = true;
        $btnStopPitchTest.disabled = false;
    } else {
        $btnPitchTest.disabled = false; // í•­ìƒ í™œì„±í™”
        $btnStopPitchTest.disabled = true;
        
        // ëª©í‘œ í”¼ì¹˜ê°€ ì„¤ì •ë˜ì—ˆìœ¼ë©´ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë³€ê²½
        if (targetPitch !== null) {
            $btnPitchTest.classList.remove('btn-outline-success');
            $btnPitchTest.classList.add('btn-success');
        } else {
            $btnPitchTest.classList.remove('btn-success');
            $btnPitchTest.classList.add('btn-outline-success');
        }
    }
}

// ê¸°ì¡´ í•¨ìˆ˜ëŠ” ë°±ì—…ìš©ìœ¼ë¡œ ìœ ì§€
function timeWarpToRef_backup(liveSeries) {
    const liveSyl = sylCuts.filter(s => s.end !== null);
    if (!liveSyl.length || !refSyll.length) return liveSeries;
    
    const n = Math.min(liveSyl.length, refSyll.length);
    const anchors = [];
    
    for (let i = 0; i < n; i++) {
        const L = liveSyl[i], R = refSyll[i];
        const lMid = (L.start + L.end) / 2;
        const rMid = (R.start + R.end) / 2;
        anchors.push({l: lMid, r: rMid});
    }
    
    return liveSeries.map(p => {
        const t = p.x;
        let k = 0;
        while (k < anchors.length && anchors[k].l < t) k++;
        
        if (k === 0) {
            const a0 = anchors[0];
            const scale = (a0.r) / (a0.l || 1e-6);
            return {x: t * scale, y: p.y, int: p.int};
        } else if (k >= anchors.length) {
            const a1 = anchors[anchors.length - 1];
            const scale = ((refStats.duration - a1.r) / ((t) - a1.l || 1e-6));
            return {x: a1.r + (t - a1.l) * scale, y: p.y, int: p.int};
        } else {
            const a0 = anchors[k - 1], a1 = anchors[k];
            const alpha = (t - a0.l) / ((a1.l - a0.l) || 1e-6);
            const x = a0.r + alpha * (a1.r - a0.r);
            return {x, y: p.y, int: p.int};
        }
    });
}

// Microphone handler - moved to setupEventHandlers function

// Reset handler - moved to setupEventHandlers function

// Save session data
async function saveSessionData(data) {
    try {
        const response = await fetch('/api/save_session', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        
        if (response.ok) {
            console.log('Session data saved successfully');
        }
    } catch (e) {
        console.error('Error saving session data:', e);
    }
}

// Initialize - removed from here since it's now in DOMContentLoaded

// Load saved files from server
async function loadSavedFilesList() {
    try {
        const response = await fetch(`${API_BASE}/api/reference_files`);
        const data = await response.json();
        
        if ($savedFiles) {
            $savedFiles.innerHTML = '<option value="">ì €ì¥ëœ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”</option>';
            
            if (data.files && data.files.length > 0) {
                data.files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.id;
                    option.textContent = `${file.title} (${file.duration?.toFixed(1)}ì´ˆ, ${file.syllable_count}ìŒì ˆ)`;
                    $savedFiles.appendChild(option);
                });
                $savedFiles.disabled = false;
            } else {
                $savedFiles.innerHTML = '<option value="">ì €ì¥ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</option>';
                $savedFiles.disabled = true;
            }
            
            // Update delete button state
            updateDeleteButtonState();
        }
    } catch (error) {
        console.error('Failed to load saved files:', error);
        if ($savedFiles) {
            $savedFiles.innerHTML = '<option value="">íŒŒì¼ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨</option>';
            $savedFiles.disabled = true;
        }
    }
}

// Load selected file from saved files
async function loadSelectedFile() {
    const fileId = $savedFiles.value;
    if (!fileId) return;
    
    try {
        $status.textContent = 'ì €ì¥ëœ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...';
        
        // Download WAV file
        const wavResponse = await fetch(`${API_BASE}/api/reference_files/${fileId}/wav`);
        const wavBlob = await wavResponse.blob();
        
        // Download TextGrid file  
        const tgResponse = await fetch(`${API_BASE}/api/reference_files/${fileId}/textgrid`);
        const tgBlob = await tgResponse.blob();
        
        // Create file objects and set to inputs
        const wavFile = new File([wavBlob], `reference_${fileId}.wav`, { type: 'audio/wav' });
        const tgFile = new File([tgBlob], `reference_${fileId}.TextGrid`, { type: 'text/plain' });
        
        // Create file list for inputs
        const wavDataTransfer = new DataTransfer();
        wavDataTransfer.items.add(wavFile);
        $wav.files = wavDataTransfer.files;
        
        const tgDataTransfer = new DataTransfer();
        tgDataTransfer.items.add(tgFile);
        $tg.files = tgDataTransfer.files;
        
        $status.textContent = 'ì €ì¥ëœ íŒŒì¼ì„ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.';
        updateButtons();
        
    } catch (error) {
        console.error('Failed to load selected file:', error);
        $status.textContent = 'íŒŒì¼ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
    }
}

// Update delete button state
function updateDeleteButtonState() {
    if ($btnDeleteSaved && $savedFiles) {
        $btnDeleteSaved.disabled = !$savedFiles.value;
    }
    if ($btnReplayPractice) {
        $btnReplayPractice.disabled = !practiceRecordingData || practiceRecordingData.length === 0;
    }
}

// Confirm delete saved file
async function confirmDeleteSavedFile() {
    const fileId = $savedFiles.value;
    if (!fileId) return;
    
    const selectedOption = $savedFiles.options[$savedFiles.selectedIndex];
    const fileName = selectedOption.textContent;
    
    if (confirm(`ì •ë§ë¡œ "${fileName}" íŒŒì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`)) {
        await deleteSavedFile(fileId);
    }
}

// Delete saved file from server
async function deleteSavedFile(fileId) {
    try {
        $status.textContent = 'íŒŒì¼ì„ ì‚­ì œí•˜ëŠ” ì¤‘...';
        
        const response = await fetch(`${API_BASE}/api/reference_files/${fileId}`, {
            method: 'DELETE'
        });
        
        const result = await response.json();
        
        if (result.status === 'success') {
            $status.textContent = 'íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.';
            
            // Reload saved files list
            await loadSavedFilesList();
            
            console.log(`ğŸ—‘ï¸ ì €ì¥ëœ íŒŒì¼ ì‚­ì œ ì„±ê³µ: ${fileId}`);
            
        } else {
            throw new Error(result.message || 'Unknown error');
        }
        
    } catch (error) {
        console.error('Delete error:', error);
        $status.textContent = 'íŒŒì¼ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
        alert('íŒŒì¼ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
    }
}

// Show save modal
function showSaveModal() {
    const modal = createSaveModal();
    document.body.appendChild(modal);
    
    const bsModal = new bootstrap.Modal(modal);
    bsModal.show();
    
    // Remove modal from DOM when closed
    modal.addEventListener('hidden.bs.modal', () => {
        document.body.removeChild(modal);
    });
}

// Create save modal
function createSaveModal() {
    const modal = document.createElement('div');
    modal.className = 'modal fade';
    modal.innerHTML = `
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">ì°¸ì¡° íŒŒì¼ ì €ì¥</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="saveForm">
                        <div class="mb-3">
                            <label for="saveTitle" class="form-label">ì œëª© *</label>
                            <input type="text" class="form-control" id="saveTitle" required 
                                   placeholder="ì˜ˆ: í•œêµ­ì–´ ê¸°ë³¸ ë¬¸ì¥ ì—°ìŠµ">
                        </div>
                        <div class="mb-3">
                            <label for="saveDescription" class="form-label">ì„¤ëª…</label>
                            <textarea class="form-control" id="saveDescription" rows="3"
                                      placeholder="íŒŒì¼ì— ëŒ€í•œ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>
                        </div>
                        <div class="mb-3">
                            <label for="saveSentence" class="form-label">ë¬¸ì¥ ë‚´ìš©</label>
                            <input type="text" class="form-control" id="saveSentence"
                                   placeholder="ì˜ˆ: ë‚´ ì¹œêµ¬ê°€ ë©´ì ‘ì— í•©ê²©í–ˆëŒ€">
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">ì·¨ì†Œ</button>
                    <button type="button" class="btn btn-success" onclick="saveReferenceFile()">ì €ì¥</button>
                </div>
            </div>
        </div>
    `;
    return modal;
}

// Save reference file to server
async function saveReferenceFile() {
    const title = document.getElementById('saveTitle').value.trim();
    const description = document.getElementById('saveDescription').value.trim();
    const sentence = document.getElementById('saveSentence').value.trim();
    
    if (!title) {
        alert('ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
        return;
    }
    
    if (!$wav.files[0] || !$tg.files[0]) {
        alert('WAV íŒŒì¼ê³¼ TextGrid íŒŒì¼ì´ ëª¨ë‘ í•„ìš”í•©ë‹ˆë‹¤.');
        return;
    }
    
    try {
        const formData = new FormData();
        formData.append('title', title);
        formData.append('description', description);
        formData.append('sentence_text', sentence);
        formData.append('wav_file', $wav.files[0]);
        formData.append('textgrid_file', $tg.files[0]);
        
        $status.textContent = 'íŒŒì¼ì„ ì €ì¥í•˜ëŠ” ì¤‘...';
        
        const response = await fetch(`${API_BASE}/api/save_reference`, {
            method: 'POST',
            body: formData
        });
        
        const result = await response.json();
        
        if (result.status === 'success') {
            $status.textContent = 'íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!';
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.querySelector('.modal'));
            modal.hide();
            
            // Reload saved files list
            await loadSavedFilesList();
            
        } else {
            throw new Error(result.message || 'Unknown error');
        }
        
    } catch (error) {
        console.error('Save error:', error);
        $status.textContent = 'íŒŒì¼ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
        alert('íŒŒì¼ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
    }
}

// ğŸ¯ ì„±ë³„ ì„ íƒ ëª¨ë‹¬ ê¸°ëŠ¥
document.addEventListener('DOMContentLoaded', function() {
    initializeGenderSelection();
    initializeLearningInterface();
});

function initializeGenderSelection() {
    // ì„±ë³„ ì˜µì…˜ ì„ íƒ ì´ë²¤íŠ¸
    document.addEventListener('click', function(e) {
        if (e.target.closest('.gender-option')) {
            const genderOption = e.target.closest('.gender-option');
            const gender = genderOption.dataset.gender;
            
            // ëª¨ë“  ì„ íƒ í•´ì œ
            document.querySelectorAll('.gender-option').forEach(opt => {
                if (opt.classList.contains('card')) {
                    opt.style.border = '2px solid transparent';
                } else {
                    opt.classList.remove('btn-primary');
                    opt.classList.add('btn-outline-secondary');
                }
            });
            
            // ì„ íƒí•œ ì˜µì…˜ ê°•ì¡°
            if (genderOption.classList.contains('card')) {
                genderOption.style.border = '2px solid #0d6efd';
            } else {
                genderOption.classList.remove('btn-outline-secondary');
                genderOption.classList.add('btn-primary');
            }
            
            selectedGender = gender;
            document.getElementById('confirmGenderSelection').disabled = false;
        }
    });
    
    // ì„±ë³„ ì„ íƒ í™•ì¸
    document.getElementById('confirmGenderSelection')?.addEventListener('click', function() {
        if (selectedGender) {
            applyGenderNormalization(selectedGender);
            const modal = bootstrap.Modal.getInstance(document.getElementById('genderSelectionModal'));
            modal.hide();
        }
    });
}

function showGenderSelectionModal(refGender, refMedian) {
    const modal = new bootstrap.Modal(document.getElementById('genderSelectionModal'));
    const genderText = refGender === 'female' ? 
        `ì—¬ì„± ìŒì„± (í‰ê·  ${refMedian.toFixed(0)}Hz)` : 
        `ë‚¨ì„± ìŒì„± (í‰ê·  ${refMedian.toFixed(0)}Hz)`;
    
    document.getElementById('referenceGenderInfo').textContent = genderText;
    
    // ì„ íƒ ì´ˆê¸°í™”
    selectedGender = null;
    document.getElementById('confirmGenderSelection').disabled = true;
    document.querySelectorAll('.gender-option').forEach(opt => {
        if (opt.classList.contains('card')) {
            opt.style.border = '2px solid transparent';
        } else {
            opt.classList.remove('btn-primary');
            opt.classList.add('btn-outline-secondary');
        }
    });
    
    modal.show();
}

function applyGenderNormalization(learnerGender) {
    console.log(`ğŸ¯ ì„±ë³„ ì •ê·œí™” ì ìš©: ${detectedReferenceGender} â†’ ${learnerGender}`);
    
    // ì •ê·œí™”ëœ ë§¤ê°œë³€ìˆ˜ë¡œ ë‹¤ì‹œ ë¶„ì„ ìš”ì²­
    analyzeReferenceWithGender(learnerGender);
}

// ğŸ¯ í•™ìŠµ ë°©ë²•ì— ë”°ë¥¸ ë²„íŠ¼ í™œì„±í™”/ë¹„í™œì„±í™”
function updateButtonsByLearningMethod(method) {
    console.log(`ğŸ¯ í•™ìŠµ ë°©ë²•ì— ë”°ë¥¸ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸: ${method}`);
    
    if (method === 'pitch') {
        // ìŒë†’ì´ í•™ìŠµ: ë…¹ìŒ ë²„íŠ¼ ì™„ì „ ë¹„í™œì„±í™”, ë¶„ì„ ë²„íŠ¼ í™œì„±í™”
        if ($btnMic) {
            $btnMic.disabled = false; // ğŸ¯ ìŒë†’ì´ í•™ìŠµì—ì„œ ë…¹ìŒ í™œì„±í™”
            $btnMic.classList.remove('disabled');
            $btnMic.style.opacity = '1';
        }
        if ($btnAnalyze) {
            $btnAnalyze.disabled = true; // ğŸ¯ ìŒë†’ì´ í•™ìŠµì—ì„œ ë¶„ì„ ë¹„í™œì„±í™”
            $btnAnalyze.classList.add('disabled');
            $btnAnalyze.style.opacity = '0.5';
        }
        console.log('ğŸ¯ ìŒë†’ì´ í•™ìŠµ ëª¨ë“œ: ë…¹ìŒ í™œì„±í™”, ë¶„ì„ ë¹„í™œì„±í™”');
        
        // ğŸ¯ ì¦‰ì‹œ updateButtons í˜¸ì¶œí•˜ì—¬ ìƒíƒœ ê°•ì œ ì—…ë°ì´íŠ¸
        updateButtons();
        
    } else if (method === 'sentence') {
        // ë¬¸ì¥ì–µì–‘ì—°ìŠµ: ë¶„ì„ ë²„íŠ¼ í™œì„±í™”, ë…¹ìŒ ë²„íŠ¼ í™œì„±í™”
        if ($btnAnalyze) {
            $btnAnalyze.disabled = false;
            $btnAnalyze.classList.remove('disabled');
            $btnAnalyze.style.opacity = '1';
        }
        if ($btnMic) {
            // ë¬¸ì¥ì–µì–‘ì—°ìŠµ: í•­ìƒ í™œì„±í™”
            $btnMic.disabled = false;
            $btnMic.classList.remove('disabled');
            $btnMic.style.opacity = '1';
        }
        console.log('ğŸ¯ ë¬¸ì¥ì–µì–‘ì—°ìŠµ ëª¨ë“œ: ë¶„ì„ í™œì„±í™”, ë…¹ìŒ í™œì„±í™”');
        
        // ğŸ¯ ì¦‰ì‹œ updateButtons í˜¸ì¶œí•˜ì—¬ ìƒíƒœ ê°•ì œ ì—…ë°ì´íŠ¸
        updateButtons();
        
    } else {
        // ë°©ë²•ì´ ì„ íƒë˜ì§€ ì•Šì€ ê²½ìš°: ëª¨ë“  ë²„íŠ¼ ë¹„í™œì„±í™”
        if ($btnMic) {
            $btnMic.disabled = true;
            $btnMic.classList.add('disabled');
            $btnMic.style.opacity = '0.5';
        }
        if ($btnAnalyze) {
            $btnAnalyze.disabled = false; // ğŸ¯ ê¸°ë³¸ì ìœ¼ë¡œ í™œì„±í™”
            $btnAnalyze.classList.remove('disabled');
            $btnAnalyze.style.opacity = '1';
        }
        console.log('ğŸ¯ í•™ìŠµ ë°©ë²• ë¯¸ì„ íƒ: ë¶„ì„ ë²„íŠ¼ í™œì„±í™”, ë…¹ìŒ ë²„íŠ¼ ë¹„í™œì„±í™”');
    }
}

// ğŸ¯ ìƒˆë¡œìš´ í•™ìŠµ ì¸í„°í˜ì´ìŠ¤ ì´ˆê¸°í™”
function initializeLearningInterface() {
    // í•™ìŠµì ì„±ë³„ ì„ íƒ ì´ë²¤íŠ¸
    document.getElementById('learner-gender')?.addEventListener('change', function(e) {
        learnerGender = e.target.value;
        updateProgress();
    });
    
    // í•™ìŠµ ë°©ë²• ì„ íƒ ì´ë²¤íŠ¸ (ìƒˆë¡œìš´ í† ê¸€ í˜•íƒœ)
    document.addEventListener('click', function(e) {
        if (e.target.closest('.learning-method-toggle')) {
            const toggle = e.target.closest('.learning-method-toggle');
            const method = toggle.dataset.method;
            const radio = toggle.querySelector('input[type="radio"]');
            
            // ë¼ë””ì˜¤ ë²„íŠ¼ ì„ íƒ
            radio.checked = true;
            
            // ëª¨ë“  í† ê¸€ ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
            document.querySelectorAll('.learning-method-toggle').forEach(t => {
                t.classList.remove('border-primary', 'bg-light');
                t.classList.add('border');
            });
            
            // ì„ íƒí•œ í† ê¸€ ê°•ì¡°
            toggle.classList.remove('border');
            toggle.classList.add('border-primary', 'bg-light');
            
            // ìƒì„¸ ì •ë³´ í† ê¸€
            const detailsId = method === 'pitch' ? 'pitchDetails' : 'sentenceDetails';
            const otherDetailsId = method === 'pitch' ? 'sentenceDetails' : 'pitchDetails';
            
            // ë‹¤ë¥¸ ìƒì„¸ ì •ë³´ ìˆ¨ê¸°ê¸°
            document.getElementById(otherDetailsId).classList.remove('show');
            
            // ì„ íƒí•œ ìƒì„¸ ì •ë³´ í‘œì‹œ
            const details = document.getElementById(detailsId);
            details.classList.toggle('show');
            
            learningMethod = method;
            
            // í•™ìŠµ ë°©ë²•ì— ë”°ë¼ ìŒì„± ë¶„ì„ ì„¹ì…˜ í‘œì‹œ/ìˆ¨ê¹€
            const audioAnalysisSection = document.getElementById('audioAnalysisSection');
            if (audioAnalysisSection) {
                // ğŸ¯ ë¬¸ì¥ì–µì–‘ì—°ìŠµë§Œ ìŒì„± ë¶„ì„ ì„¹ì…˜ í‘œì‹œ, ìŒë†’ì´ í•™ìŠµì€ ìˆ¨ê¹€
                if (method === 'sentence') {
                    audioAnalysisSection.classList.remove('d-none');
                } else {
                    audioAnalysisSection.classList.add('d-none');
                }
            }
            
            // ğŸ¯ í•™ìŠµ ë°©ë²•ì— ë”°ë¥¸ ë²„íŠ¼ í™œì„±í™”/ë¹„í™œì„±í™”
            updateButtonsByLearningMethod(method);
            
            updateProgress();
        }
    });
    
    // í† ê¸€ í—¤ë” í´ë¦­ì‹œ í™”ì‚´í‘œ íšŒì „ (ê¸°ë³¸ ìƒíƒœ: ì ‘í˜€ì§)
    const chevron = document.getElementById('learningMethodChevron');
    if (chevron) {
        // ê¸°ë³¸ ìƒíƒœë¥¼ 0ë„ë¡œ ì„¤ì • (ì ‘í˜€ì§„ ìƒíƒœ)
        chevron.style.transform = 'rotate(0deg)';
    }
    
    document.querySelector('[data-bs-target="#learningMethodCollapse"]')?.addEventListener('click', function() {
        setTimeout(() => {
            const isExpanded = document.getElementById('learningMethodCollapse').classList.contains('show');
            chevron.style.transform = isExpanded ? 'rotate(180deg)' : 'rotate(0deg)';
        }, 150);
    });
    
    // í†µí•© ë…¹ìŒ ë²„íŠ¼
    document.getElementById('btnUnifiedRecord')?.addEventListener('click', startUnifiedRecording);
    document.getElementById('btnStopRecord')?.addEventListener('click', stopUnifiedRecording);
    
    // ì´ˆê¸° ìƒíƒœ ì„¤ì • - ì•„ë¬´ê²ƒë„ ì„ íƒë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ì‹œì‘
    learningMethod = null; // ëª…ì‹œì ìœ¼ë¡œ nullë¡œ ì„¤ì •
    updateButtonsByLearningMethod(null); // ì´ˆê¸° ë²„íŠ¼ ìƒíƒœ ì„¤ì •
    updateProgress();
}

// í† ê¸€ ìƒì„¸ ì •ë³´ëŠ” HTMLì—ì„œ ì§ì ‘ ê´€ë¦¬í•˜ë¯€ë¡œ ì´ í•¨ìˆ˜ëŠ” ì œê±°

function updateProgress() {
    const recordBtn = document.getElementById('btnUnifiedRecord');
    
    // ğŸ¯ ê°„ë‹¨í•œ ì¡°ê±´ìœ¼ë¡œ ë³€ê²½: í•™ìŠµë°©ë²•ë§Œ ì„ íƒë˜ë©´ í™œì„±í™”
    const canRecord = learningMethod === 'sentence'; // ë¬¸ì¥ì–µì–‘ì—°ìŠµì¼ ë•Œë§Œ ë…¹ìŒ ê°€ëŠ¥
    
    if (recordBtn) {
        recordBtn.disabled = !canRecord;
        console.log(`ğŸ¯ ë…¹ìŒ ë²„íŠ¼ ìƒíƒœ: ${canRecord ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'} (í•™ìŠµë°©ë²•: ${learningMethod})`);
    }
    
    // ìƒíƒœ í…ìŠ¤íŠ¸ëŠ” í‘œì‹œí•˜ì§€ ì•ŠìŒ (ì™„ì „ ì‚­ì œ)
}

function startUnifiedRecording() {
    if (learningMethod === 'pitch') {
        // ìŒë†’ì´ í•™ìŠµ ëª¨ë“œ
        console.log('ğŸ¯ ìŒë†’ì´ í•™ìŠµ ë…¹ìŒ ì‹œì‘');
        document.getElementById('learning-status').textContent = 'ìŒë†’ì´ ì—°ìŠµ ì¤‘';
        // ê¸°ì¡´ í”¼ì¹˜ í…ŒìŠ¤íŠ¸ ë¡œì§ í™œìš©
        startPitchTest();
    } else if (learningMethod === 'sentence') {
        // ë¬¸ì¥ ì–µì–‘ í•™ìŠµ ëª¨ë“œ
        console.log('ğŸ¯ ë¬¸ì¥ ì–µì–‘ í•™ìŠµ ë…¹ìŒ ì‹œì‘');
        document.getElementById('learning-status').textContent = 'ë¬¸ì¥ ì–µì–‘ ì—°ìŠµ ì¤‘';
        // ê¸°ì¡´ ë§ˆì´í¬ ë…¹ìŒ ë¡œì§ í™œìš©
        startMicRecording();
    }
    
    document.getElementById('btnUnifiedRecord').disabled = true;
    document.getElementById('btnStopRecord').disabled = false;
}

function stopUnifiedRecording() {
    console.log('ğŸ¯ í†µí•© ë…¹ìŒ ì •ì§€');
    
    // ëª¨ë“  ë…¹ìŒ ì •ì§€
    if (pitchTestActive) {
        stopPitchTest();
    }
    if (isListening) {
        stopMicRecording();
    }
    
    document.getElementById('btnUnifiedRecord').disabled = false;
    document.getElementById('btnStopRecord').disabled = true;
    document.getElementById('learning-status').textContent = 'ë…¹ìŒ ì™„ë£Œ';
}

async function analyzeReferenceWithGender(targetGender) {
    if (!$wav.files[0] || !$tg.files[0]) return;
    
    try {
        $status.textContent = `ì„±ë³„ ì •ê·œí™” ì ìš© ì¤‘... (${detectedReferenceGender} â†’ ${targetGender})`;
        
        const formData = new FormData();
        formData.append('wav', $wav.files[0]);
        formData.append('textgrid', $tg.files[0]);
        
        const response = await fetch(`${API_BASE}/analyze_ref?target_gender=${targetGender}&t=${Date.now()}`, {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const js = await response.json();
        
        // ì •ê·œí™”ëœ ë°ì´í„°ë¡œ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        if (js.curve && js.syllables) {
            refCurve = js.curve;
            refSyll = js.syllables;
            refStats = js.stats;
            refMedian = js.stats.sentence_median || 200;
            
            console.log('ğŸ¯ ì •ê·œí™”ëœ ë°ì´í„° ìˆ˜ì‹ :', refCurve.length, 'í¬ì¸íŠ¸');
            
            // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
            if (chart && refCurve.length > 0) {
                const chartData = refCurve.map(p => ({x: p.t, y: p.semitone || 0}));
                chart.data.datasets[0].data = chartData;
                chart.update();
            }
            
            // ìŒì ˆ ë¶„ì„ í…Œì´ë¸” ì—…ë°ì´íŠ¸
            if (js.syllable_analysis) {
                updateSyllableAnalysisTable(js.syllable_analysis);
            }
            
            updateButtons();
            updateProgress(); // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
            $status.textContent = `ì„±ë³„ ì •ê·œí™” ì™„ë£Œ (${detectedReferenceGender} â†’ ${targetGender})`;
        }
        
    } catch (error) {
        console.error('ì„±ë³„ ì •ê·œí™” ì˜¤ë¥˜:', error);
        $status.textContent = 'ì„±ë³„ ì •ê·œí™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
    }
}
